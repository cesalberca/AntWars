<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Assembly-CSharp</name>
    </assembly>
    <members>
        <member name="T:AILerp">
            Linearly interpolating movement script.
             This movement script will follow the path exactly, it uses linear interpolation to move between the waypoints in the path.
             This is desirable for some types of games.
             It also works in 2D.
            
             Recommended setup:
            
             This depends on what type of movement you are aiming for.
             If you are aiming for movement where the unit follows the path exactly (you are likely using a grid or point graph)
             the default settings on this component should work quite well, however I recommend that you adjust the StartEndModifier
             on the Seeker component: set the 'Exact Start Point' field to 'NodeConnection' and the 'Exact End Point' field to 'SnapToNode'.
            
             If you on the other hand want smoother movement I recommend adding the Simple Smooth Modifier to the GameObject as well.
             You may also want to tweak the #rotationSpeed.
            
             \ingroup movementscripts
        </member>
        <member name="F:AILerp.repathRate">
            Determines how often it will search for new paths.
            If you have fast moving targets or AIs, you might want to set it to a lower value.
            The value is in seconds between path requests.
        </member>
        <member name="F:AILerp.target">
            Target to move towards.
            The AI will try to follow/move towards this target.
            It can be a point on the ground where the player has clicked in an RTS for example, or it can be the player object in a zombie game.
        </member>
        <member name="F:AILerp.canSearch">
            Enables or disables searching for paths.
            Setting this to false does not stop any active path requests from being calculated or stop it from continuing to follow the current path.
            \see #canMove
        </member>
        <member name="F:AILerp.canMove">
            Enables or disables movement.
            \see #canSearch 
        </member>
        <member name="F:AILerp.speed">
            Speed in world units 
        </member>
        <member name="F:AILerp.enableRotation">
            If true, the AI will rotate to face the movement direction 
        </member>
        <member name="F:AILerp.rotationIn2D">
            If true, rotation will only be done along the Z axis 
        </member>
        <member name="F:AILerp.rotationSpeed">
            How quickly to rotate 
        </member>
        <member name="F:AILerp.interpolatePathSwitches">
            If true, some interpolation will be done when a new path has been calculated.
            This is used to avoid short distance teleportation.
        </member>
        <member name="F:AILerp.switchPathInterpolationSpeed">
            How quickly to interpolate to the new path 
        </member>
        <member name="F:AILerp.seeker">
            Cached Seeker component 
        </member>
        <member name="F:AILerp.tr">
            Cached Transform component 
        </member>
        <member name="F:AILerp.lastRepath">
            Time when the last path request was sent 
        </member>
        <member name="F:AILerp.path">
            Current path which is followed 
        </member>
        <member name="F:AILerp.currentWaypointIndex">
            Current index in the path which is current target 
        </member>
        <member name="F:AILerp.distanceAlongSegment">
            How far the AI has moved along the current segment 
        </member>
        <member name="P:AILerp.targetReached">
            True if the end-of-path is reached.
            \see TargetReached 
        </member>
        <member name="F:AILerp.canSearchAgain">
            Only when the previous path has been returned should be search for a new path 
        </member>
        <member name="F:AILerp.previousMovementOrigin">
            When a new path was returned, the AI was moving along this ray.
            Used to smoothly interpolate between the previous movement and the movement along the new path.
            The speed is equal to movement direction.
        </member>
        <member name="F:AILerp.startHasRun">
            Holds if the Start function has been run.
            Used to test if coroutines should be started in OnEnable to prevent calculating paths
            in the awake stage (or rather before start on frame 0).
        </member>
        <member name="M:AILerp.Awake">
            Initializes reference variables.
            If you override this function you should in most cases call base.Awake () at the start of it.
            
        </member>
        <member name="M:AILerp.Start">
            Starts searching for paths.
            If you override this function you should in most cases call base.Start () at the start of it.
            \see OnEnable
            \see RepeatTrySearchPath
        </member>
        <member name="M:AILerp.OnEnable">
            Run at start and when reenabled.
             Starts RepeatTrySearchPath.
            
             \see Start
        </member>
        <member name="M:AILerp.RepeatTrySearchPath">
            Tries to search for a path every #repathRate seconds.
            \see TrySearchPath
        </member>
        <member name="M:AILerp.TrySearchPath">
            Tries to search for a path.
             Will search for a new path if there was a sufficient time since the last repath and both
             #canSearchAgain and #canSearch are true and there is a target.
            
             \returns The time to wait until calling this function again (based on #repathRate)
        </member>
        <member name="M:AILerp.SearchPath">
            Requests a path to the target.
            Some inheriting classes will prevent the path from being requested immediately when
            this function is called, for example when the AI is currently traversing a special path segment
            in which case it is usually a bad idea to search for a new path.
        </member>
        <member name="M:AILerp.ForceSearchPath">
            Requests a path to the target.
            Bypasses 'is-it-a-good-time-to-request-a-path' checks.
        </member>
        <member name="M:AILerp.OnTargetReached">
            The end of the path has been reached.
            If you want custom logic for when the AI has reached it's destination
            add it here
            You can also create a new script which inherits from this one
            and override the function in that script.
        </member>
        <member name="M:AILerp.OnPathComplete(Pathfinding.Path)">
            Called when a requested path has finished calculation.
            A path is first requested by #SearchPath, it is then calculated, probably in the same or the next frame.
            Finally it is returned to the seeker which forwards it to this function.\n
        </member>
        <member name="M:AILerp.ConfigureNewPath">
            Finds the closest point on the current path.
            Sets #currentWaypointIndex and #lerpTime to the appropriate values.
        </member>
        <member name="M:AILerp.CalculateNextPosition(UnityEngine.Vector3@)">
            Calculate the AI's next position (one frame in the future).
            \param direction The direction of the segment the AI is currently traversing. Not normalized.
        </member>
        <member name="T:AIPath">
            AI for following paths.
             This AI is the default movement script which comes with the A* Pathfinding Project.
             It is in no way required by the rest of the system, so feel free to write your own. But I hope this script will make it easier
             to set up movement for the characters in your game. This script is not written for high performance, so I do not recommend using it for large groups of units.
             \n
             \n
             This script will try to follow a target transform, in regular intervals, the path to that target will be recalculated.
             It will on FixedUpdate try to move towards the next point in the path.
             However it will only move in the forward direction, but it will rotate around it's Y-axis
             to make it reach the target.
            
             \section variables Quick overview of the variables
             In the inspector in Unity, you will see a bunch of variables. You can view detailed information further down, but here's a quick overview.\n
             The #repathRate determines how often it will search for new paths, if you have fast moving targets, you might want to set it to a lower value.\n
             The #target variable is where the AI will try to move, it can be a point on the ground where the player has clicked in an RTS for example.
             Or it can be the player object in a zombie game.\n
             The speed is self-explanatory, so is turningSpeed, however #slowdownDistance might require some explanation.
             It is the approximate distance from the target where the AI will start to slow down. Note that this doesn't only affect the end point of the path
             but also any intermediate points, so be sure to set #forwardLook and #pickNextWaypointDist to a higher value than this.\n
             #pickNextWaypointDist is simply determines within what range it will switch to target the next waypoint in the path.\n
             #forwardLook will try to calculate an interpolated target point on the current segment in the path so that it has a distance of #forwardLook from the AI\n
             Below is an image illustrating several variables as well as some internal ones, but which are relevant for understanding how it works.
             Note that the #forwardLook range will not match up exactly with the target point practically, even though that's the goal.
             \shadowimage{aipath_variables.png}
             This script has many movement fallbacks.
             If it finds a NavmeshController, it will use that, otherwise it will look for a character controller, then for a rigidbody and if it hasn't been able to find any
             it will use Transform.Translate which is guaranteed to always work.
        </member>
        <member name="F:AIPath.repathRate">
            Determines how often it will search for new paths.
            If you have fast moving targets or AIs, you might want to set it to a lower value.
            The value is in seconds between path requests.
        </member>
        <member name="F:AIPath.target">
            Target to move towards.
            The AI will try to follow/move towards this target.
            It can be a point on the ground where the player has clicked in an RTS for example, or it can be the player object in a zombie game.
        </member>
        <member name="F:AIPath.canSearch">
            Enables or disables searching for paths.
            Setting this to false does not stop any active path requests from being calculated or stop it from continuing to follow the current path.
            \see #canMove
        </member>
        <member name="F:AIPath.canMove">
            Enables or disables movement.
            \see #canSearch 
        </member>
        <member name="F:AIPath.speed">
            Maximum velocity.
            This is the maximum speed in world units per second.
        </member>
        <member name="F:AIPath.turningSpeed">
            Rotation speed.
            Rotation is calculated using Quaternion.SLerp. This variable represents the damping, the higher, the faster it will be able to rotate.
        </member>
        <member name="F:AIPath.slowdownDistance">
            Distance from the target point where the AI will start to slow down.
            Note that this doesn't only affect the end point of the path
            but also any intermediate points, so be sure to set #forwardLook and #pickNextWaypointDist to a higher value than this
        </member>
        <member name="F:AIPath.pickNextWaypointDist">
            Determines within what range it will switch to target the next waypoint in the path 
        </member>
        <member name="F:AIPath.forwardLook">
            Target point is Interpolated on the current segment in the path so that it has a distance of #forwardLook from the AI.
            See the detailed description of AIPath for an illustrative image 
        </member>
        <member name="F:AIPath.endReachedDistance">
            Distance to the end point to consider the end of path to be reached.
            When this has been reached, the AI will not move anymore until the target changes and OnTargetReached will be called.
        </member>
        <member name="F:AIPath.closestOnPathCheck">
            Do a closest point on path check when receiving path callback.
            Usually the AI has moved a bit between requesting the path, and getting it back, and there is usually a small gap between the AI
            and the closest node.
            If this option is enabled, it will simulate, when the path callback is received, movement between the closest node and the current
            AI position. This helps to reduce the moments when the AI just get a new path back, and thinks it ought to move backwards to the start of the new path
            even though it really should just proceed forward.
        </member>
        <member name="F:AIPath.seeker">
            Cached Seeker component 
        </member>
        <member name="F:AIPath.tr">
            Cached Transform component 
        </member>
        <member name="F:AIPath.lastRepath">
            Time when the last path request was sent 
        </member>
        <member name="F:AIPath.path">
            Current path which is followed 
        </member>
        <member name="F:AIPath.controller">
            Cached CharacterController component 
        </member>
        <member name="F:AIPath.rigid">
            Cached Rigidbody component 
        </member>
        <member name="F:AIPath.currentWaypointIndex">
            Current index in the path which is current target 
        </member>
        <member name="F:AIPath.targetReached">
            Holds if the end-of-path is reached
            \see TargetReached 
        </member>
        <member name="F:AIPath.canSearchAgain">
            Only when the previous path has been returned should be search for a new path 
        </member>
        <member name="P:AIPath.TargetReached">
            Returns if the end-of-path has been reached
            \see targetReached 
        </member>
        <member name="F:AIPath.startHasRun">
            Holds if the Start function has been run.
            Used to test if coroutines should be started in OnEnable to prevent calculating paths
            in the awake stage (or rather before start on frame 0).
        </member>
        <member name="M:AIPath.Awake">
            Initializes reference variables.
            If you override this function you should in most cases call base.Awake () at the start of it.
            
        </member>
        <member name="M:AIPath.Start">
            Starts searching for paths.
            If you override this function you should in most cases call base.Start () at the start of it.
            \see OnEnable
            \see RepeatTrySearchPath
        </member>
        <member name="M:AIPath.OnEnable">
            Run at start and when reenabled.
             Starts RepeatTrySearchPath.
            
             \see Start
        </member>
        <member name="M:AIPath.RepeatTrySearchPath">
            Tries to search for a path every #repathRate seconds.
            \see TrySearchPath
        </member>
        <member name="M:AIPath.TrySearchPath">
            Tries to search for a path.
             Will search for a new path if there was a sufficient time since the last repath and both
             #canSearchAgain and #canSearch are true and there is a target.
            
             \returns The time to wait until calling this function again (based on #repathRate)
        </member>
        <member name="M:AIPath.SearchPath">
            Requests a path to the target 
        </member>
        <member name="M:AIPath.OnPathComplete(Pathfinding.Path)">
            Called when a requested path has finished calculation.
            A path is first requested by #SearchPath, it is then calculated, probably in the same or the next frame.
            Finally it is returned to the seeker which forwards it to this function.\n
        </member>
        <member name="F:AIPath.targetPoint">
            Point to where the AI is heading.
            Filled in by #CalculateVelocity 
        </member>
        <member name="F:AIPath.targetDirection">
            Relative direction to where the AI is heading.
            Filled in by #CalculateVelocity 
        </member>
        <member name="M:AIPath.CalculateVelocity(UnityEngine.Vector3)">
            Calculates desired velocity.
            Finds the target path segment and returns the forward direction, scaled with speed.
            A whole bunch of restrictions on the velocity is applied to make sure it doesn't overshoot, does not look too far ahead,
            and slows down when close to the target.
            /see speed
            /see endReachedDistance
            /see slowdownDistance
            /see CalculateTargetPoint
            /see targetPoint
            /see targetDirection
            /see currentWaypointIndex
        </member>
        <member name="M:AIPath.RotateTowards(UnityEngine.Vector3)">
            Rotates in the specified direction.
            Rotates around the Y-axis.
            \see turningSpeed
        </member>
        <member name="M:AIPath.CalculateTargetPoint(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Calculates target point from the current line segment.
            \param p Current position
            \param a Line segment start
            \param b Line segment end
            The returned point will lie somewhere on the line segment.
            \see #forwardLook
            \todo This function uses .magnitude quite a lot, can it be optimized?
        </member>
        <member name="T:Seeker">
            Handles path calls for a single unit.
            \ingroup relevant
            This is a component which is meant to be attached to a single unit (AI, Robot, Player, whatever) to handle it's pathfinding calls.
            It also handles post-processing of paths using modifiers.
            \see \ref calling-pathfinding
        </member>
        <member name="F:Seeker.drawGizmos">
            Enables drawing of the last calculated path using Gizmos.
             The path will show up in green.
            
             \see OnDrawGizmos
        </member>
        <member name="F:Seeker.detailedGizmos">
            Enables drawing of the non-postprocessed path using Gizmos.
             The path will show up in orange.
            
             Requires that #drawGizmos is true.
            
             This will show the path before any post processing such as smoothing is applied.
            
             \see drawGizmos
             \see OnDrawGizmos
        </member>
        <member name="F:Seeker.startEndModifier">
            Path modifier which tweaks the start and end points of a path 
        </member>
        <member name="F:Seeker.traversableTags">
            The tags which the Seeker can traverse.
            
             \note This field is a bitmask.
             \see https://en.wikipedia.org/wiki/Mask_(computing)
        </member>
        <member name="F:Seeker.traversableTagsCompatibility">
            Required for serialization backwards compatibility.
            \since 3.6.8
        </member>
        <member name="F:Seeker.tagPenalties">
            Penalties for each tag.
             Tag 0 which is the default tag, will have added a penalty of tagPenalties[0].
             These should only be positive values since the A* algorithm cannot handle negative penalties.
            
             \note This array should always have a length of 32 otherwise the system will ignore it.
            
             \see Pathfinding.Path.tagPenalties
        </member>
        <member name="F:Seeker.pathCallback">
            Callback for when a path is completed.
            Movement scripts should register to this delegate.\n
            A temporary callback can also be set when calling StartPath, but that delegate will only be called for that path
        </member>
        <member name="F:Seeker.preProcessPath">
            Called before pathfinding is started 
        </member>
        <member name="F:Seeker.postProcessPath">
            Called after a path has been calculated, right before modifiers are executed.
            Can be anything which only modifies the positions (Vector3[]).
        </member>
        <member name="F:Seeker.lastCompletedVectorPath">
            Used for drawing gizmos 
        </member>
        <member name="F:Seeker.lastCompletedNodePath">
            Used for drawing gizmos 
        </member>
        <member name="F:Seeker.path">
            The current path 
        </member>
        <member name="F:Seeker.prevPath">
            Previous path. Used to draw gizmos 
        </member>
        <member name="F:Seeker.onPathDelegate">
            Cached delegate to avoid allocating one every time a path is started 
        </member>
        <member name="F:Seeker.tmpPathCallback">
            Temporary callback only called for the current path. This value is set by the StartPath functions 
        </member>
        <member name="F:Seeker.lastPathID">
            The path ID of the last path queried 
        </member>
        <member name="F:Seeker.modifiers">
            Internal list of all modifiers 
        </member>
        <member name="M:Seeker.Awake">
            Initializes a few variables 
        </member>
        <member name="M:Seeker.GetCurrentPath">
            Path that is currently being calculated or was last calculated.
             You should rarely have to use this. Instead get the path when the path callback is called.
            
             \see pathCallback
        </member>
        <member name="M:Seeker.OnDestroy">
            Cleans up some variables.
             Releases any eventually claimed paths.
             Calls OnDestroy on the #startEndModifier.
            
             \see ReleaseClaimedPath
             \see startEndModifier
        </member>
        <member name="M:Seeker.ReleaseClaimedPath">
            Releases the path used for gizmos (if any).
             The seeker keeps the latest path claimed so it can draw gizmos.
             In some cases this might not be desireable and you want it released.
             In that case, you can call this method to release it (not that path gizmos will then not be drawn).
            
             If you didn't understand anything from the description above, you probably don't need to use this method.
            
             \see \ref pooling
        </member>
        <member name="M:Seeker.RegisterModifier(Pathfinding.IPathModifier)">
            Called by modifiers to register themselves 
        </member>
        <member name="M:Seeker.DeregisterModifier(Pathfinding.IPathModifier)">
            Called by modifiers when they are disabled or destroyed 
        </member>
        <member name="M:Seeker.PostProcess(Pathfinding.Path)">
            Post Processes the path.
            This will run any modifiers attached to this GameObject on the path.
            This is identical to calling RunModifiers(ModifierPass.PostProcess, path)
            \see RunModifiers
            \since Added in 3.2
        </member>
        <member name="M:Seeker.RunModifiers(Seeker.ModifierPass,Pathfinding.Path)">
            Runs modifiers on path \a p 
        </member>
        <member name="M:Seeker.IsDone">
            Is the current path done calculating.
             Returns true if the current #path has been returned or if the #path is null.
            
             \note Do not confuse this with Pathfinding.Path.IsDone. They usually return the same value, but not always
             since the path might be completely calculated, but it has not yet been processed by the Seeker.
            
             \since Added in 3.0.8
             \version Behaviour changed in 3.2
        </member>
        <member name="M:Seeker.OnPathComplete(Pathfinding.Path)">
            Called when a path has completed.
            This should have been implemented as optional parameter values, but that didn't seem to work very well with delegates (the values weren't the default ones)
            \see OnPathComplete(Path,bool,bool)
        </member>
        <member name="M:Seeker.OnPathComplete(Pathfinding.Path,System.Boolean,System.Boolean)">
            Called when a path has completed.
            Will post process it and return it by calling #tmpPathCallback and #pathCallback
        </member>
        <!-- Badly formed XML comment ignored for member "M:Seeker.GetNewPath(UnityEngine.Vector3,UnityEngine.Vector3)" -->
        <member name="M:Seeker.StartPath(UnityEngine.Vector3,UnityEngine.Vector3)">
            Call this function to start calculating a path.
            \param start		The start point of the path
            \param end		The end point of the path
        </member>
        <member name="M:Seeker.StartPath(UnityEngine.Vector3,UnityEngine.Vector3,OnPathDelegate)">
            Call this function to start calculating a path.
            
             \param start		The start point of the path
             \param end		The end point of the path
             \param callback	The function to call when the path has been calculated
            
             \a callback will be called when the path has completed.
             \a Callback will not be called if the path is canceled (e.g when a new path is requested before the previous one has completed) 
        </member>
        <member name="M:Seeker.StartPath(UnityEngine.Vector3,UnityEngine.Vector3,OnPathDelegate,System.Int32)">
            Call this function to start calculating a path.
            
             \param start		The start point of the path
             \param end		The end point of the path
             \param callback	The function to call when the path has been calculated
             \param graphMask	Mask used to specify which graphs should be searched for close nodes. See Pathfinding.NNConstraint.graphMask.
            
             \a callback will be called when the path has completed.
             \a Callback will not be called if the path is canceled (e.g when a new path is requested before the previous one has completed) 
        </member>
        <member name="M:Seeker.StartPath(Pathfinding.Path,OnPathDelegate,System.Int32)">
            Call this function to start calculating a path.
            
             \param p			The path to start calculating
             \param callback	The function to call when the path has been calculated
             \param graphMask	Mask used to specify which graphs should be searched for close nodes. See Pathfinding.NNConstraint.graphMask.
            
             \a callback will be called when the path has completed.
             \a Callback will not be called if the path is canceled (e.g when a new path is requested before the previous one has completed)
        </member>
        <member name="M:Seeker.StartPathInternal(Pathfinding.Path,OnPathDelegate)">
            Internal method to start a path and mark it as the currently active path 
        </member>
        <member name="M:Seeker.OnDrawGizmos">
            Draws gizmos for the Seeker 
        </member>
        <member name="M:Seeker.UnityEngine#ISerializationCallbackReceiver#OnBeforeSerialize">
            Handle serialization backwards compatibility 
        </member>
        <member name="M:Seeker.UnityEngine#ISerializationCallbackReceiver#OnAfterDeserialize">
            Handle serialization backwards compatibility 
        </member>
        <member name="P:Pathfinding.AstarData.active">
            Shortcut to AstarPath.active 
        </member>
        <member name="P:Pathfinding.AstarData.navmesh">
            Shortcut to the first NavMeshGraph.
            Updated at scanning time
        </member>
        <member name="P:Pathfinding.AstarData.gridGraph">
            Shortcut to the first GridGraph.
            Updated at scanning time
        </member>
        <member name="P:Pathfinding.AstarData.pointGraph">
            Shortcut to the first PointGraph.
            Updated at scanning time
        </member>
        <member name="P:Pathfinding.AstarData.graphTypes">
            All supported graph types.
            Populated through reflection search
        </member>
        <member name="F:Pathfinding.AstarData.graphs">
            All graphs this instance holds.
            This will be filled only after deserialization has completed.
            May contain null entries if graph have been removed.
        </member>
        <member name="F:Pathfinding.AstarData.dataString">
            Serialized data for all graphs and settings.
             Stored as a base64 encoded string because otherwise Unity's Undo system would sometimes corrupt the byte data (because it only stores deltas).
            
             This can be accessed as a byte array from the #data property.
            
             \since 3.6.1
        </member>
        <member name="F:Pathfinding.AstarData.upgradeData">
            Data from versions from before 3.6.1.
            Used for handling upgrades
            \since 3.6.1
        </member>
        <member name="P:Pathfinding.AstarData.data">
            Serialized data for all graphs and settings 
        </member>
        <member name="F:Pathfinding.AstarData.data_backup">
            Backup data if deserialization failed.
        </member>
        <member name="F:Pathfinding.AstarData.file_cachedStartup">
            Serialized data for cached startup.
            If set, on start the graphs will be deserialized from this file.
        </member>
        <member name="F:Pathfinding.AstarData.data_cachedStartup">
            Serialized data for cached startup.
            
             \deprecated Deprecated since 3.6, AstarData.file_cachedStartup is now used instead
        </member>
        <member name="F:Pathfinding.AstarData.cacheStartup">
            Should graph-data be cached.
            Caching the startup means saving the whole graphs, not only the settings to an internal array (#data_cachedStartup) which can
            be loaded faster than scanning all graphs at startup. This is setup from the editor.
        </member>
        <member name="M:Pathfinding.AstarData.Awake">
            Loads the graphs from memory, will load cached graphs if any exists 
        </member>
        <member name="M:Pathfinding.AstarData.UpdateShortcuts">
            Updates shortcuts to the first graph of different types.
            Hard coding references to some graph types is not really a good thing imo. I want to keep it dynamic and flexible.
            But these references ease the use of the system, so I decided to keep them.\n
        </member>
        <member name="M:Pathfinding.AstarData.LoadFromCache">
            Load from data from #file_cachedStartup 
        </member>
        <member name="M:Pathfinding.AstarData.SerializeGraphs">
            Serializes all graphs settings to a byte array.
            \see DeserializeGraphs(byte[])
        </member>
        <member name="M:Pathfinding.AstarData.SerializeGraphs(Pathfinding.Serialization.SerializeSettings)">
            Serializes all graphs settings and optionally node data to a byte array.
            \see DeserializeGraphs(byte[])
            \see Pathfinding.Serialization.SerializeSettings
        </member>
        <member name="M:Pathfinding.AstarData.SerializeGraphs(Pathfinding.Serialization.SerializeSettings,System.UInt32@)">
            Main serializer function.
            Serializes all graphs to a byte array
            A similar function exists in the AstarPathEditor.cs script to save additional info 
        </member>
        <member name="M:Pathfinding.AstarData.SerializeGraphsPart(Pathfinding.Serialization.AstarSerializer)">
            Serializes common info to the serializer.
            Common info is what is shared between the editor serialization and the runtime serializer.
            This is mostly everything except the graph inspectors which serialize some extra data in the editor
        </member>
        <member name="M:Pathfinding.AstarData.DeserializeGraphs">
            Deserializes graphs from #data 
        </member>
        <member name="M:Pathfinding.AstarData.ClearGraphs">
            Destroys all graphs and sets graphs to null 
        </member>
        <member name="M:Pathfinding.AstarData.DeserializeGraphs(System.Byte[])">
            Deserializes graphs from the specified byte array.
            If an error occured, it will try to deserialize using the old deserializer.
            A warning will be logged if all deserializers failed.
        </member>
        <member name="M:Pathfinding.AstarData.DeserializeGraphsAdditive(System.Byte[])">
            Deserializes graphs from the specified byte array additively.
            If an error ocurred, it will try to deserialize using the old deserializer.
            A warning will be logged if all deserializers failed.
            This function will add loaded graphs to the current ones
        </member>
        <member name="M:Pathfinding.AstarData.DeserializeGraphsPart(Pathfinding.Serialization.AstarSerializer)">
            Deserializes common info.
            Common info is what is shared between the editor serialization and the runtime serializer.
            This is mostly everything except the graph inspectors which serialize some extra data in the editor
        </member>
        <member name="M:Pathfinding.AstarData.DeserializeGraphsPartAdditive(Pathfinding.Serialization.AstarSerializer)">
            Deserializes common info additively
            Common info is what is shared between the editor serialization and the runtime serializer.
            This is mostly everything except the graph inspectors which serialize some extra data in the editor
        </member>
        <member name="M:Pathfinding.AstarData.FindGraphTypes">
            Find all graph types supported in this build.
            Using reflection, the assembly is searched for types which inherit from NavGraph. 
        </member>
        <member name="M:Pathfinding.AstarData.GetGraphType(System.String)">
             \returns A System.Type which matches the specified \a type string. If no mathing graph type was found, null is returned
            
             \deprecated
        </member>
        <member name="M:Pathfinding.AstarData.CreateGraph(System.String)">
            Creates a new instance of a graph of type \a type. If no matching graph type was found, an error is logged and null is returned
             \returns The created graph
             \see CreateGraph(System.Type)
            
             \deprecated
        </member>
        <member name="M:Pathfinding.AstarData.CreateGraph(System.Type)">
            Creates a new graph instance of type \a type
            \see CreateGraph(string) 
        </member>
        <member name="M:Pathfinding.AstarData.AddGraph(System.String)">
            Adds a graph of type \a type to the #graphs array
            
             \deprecated
        </member>
        <member name="M:Pathfinding.AstarData.AddGraph(System.Type)">
            Adds a graph of type \a type to the #graphs array 
        </member>
        <member name="M:Pathfinding.AstarData.AddGraph(Pathfinding.NavGraph)">
            Adds the specified graph to the #graphs array 
        </member>
        <member name="M:Pathfinding.AstarData.RemoveGraph(Pathfinding.NavGraph)">
            Removes the specified graph from the #graphs array and Destroys it in a safe manner.
             To avoid changing graph indices for the other graphs, the graph is simply nulled in the array instead
             of actually removing it from the array.
             The empty position will be reused if a new graph is added.
            
             \returns True if the graph was sucessfully removed (i.e it did exist in the #graphs array). False otherwise.
            
            
             \version Changed in 3.2.5 to call SafeOnDestroy before removing
             and nulling it in the array instead of removing the element completely in the #graphs array.
            
        </member>
        <member name="M:Pathfinding.AstarData.GetGraph(Pathfinding.GraphNode)">
            Returns the graph which contains the specified node.
             The graph must be in the #graphs array.
            
             \returns Returns the graph which contains the node. Null if the graph wasn't found
        </member>
        <member name="M:Pathfinding.AstarData.FindGraphOfType(System.Type)">
            Returns the first graph of type \a type found in the #graphs array. Returns null if none was found 
        </member>
        <member name="M:Pathfinding.AstarData.FindGraphsOfType(System.Type)">
            Loop through this function to get all graphs of type 'type'
            \code foreach (GridGraph graph in AstarPath.astarData.FindGraphsOfType (typeof(GridGraph))) {
             //Do something with the graph
            } \endcode
            \see AstarPath.RegisterSafeNodeUpdate 
        </member>
        <member name="M:Pathfinding.AstarData.GetUpdateableGraphs">
            All graphs which implements the UpdateableGraph interface
            \code foreach (IUpdatableGraph graph in AstarPath.astarData.GetUpdateableGraphs ()) {
             //Do something with the graph
            } \endcode
            \see AstarPath.RegisterSafeNodeUpdate
            \see Pathfinding.IUpdatableGraph 
        </member>
        <member name="M:Pathfinding.AstarData.GetRaycastableGraphs">
            All graphs which implements the UpdateableGraph interface
            \code foreach (IRaycastableGraph graph in AstarPath.astarData.GetRaycastableGraphs ()) {
             //Do something with the graph
            } \endcode
            \see Pathfinding.IRaycastableGraph
        </member>
        <member name="M:Pathfinding.AstarData.GetGraphIndex(Pathfinding.NavGraph)">
            Gets the index of the NavGraph in the #graphs array 
        </member>
        <member name="T:Pathfinding.AstarSplines">
            Contains various spline functions.
            \ingroup utils
        </member>
        <member name="M:Pathfinding.AstarSplines.CubicBezier(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            Returns a point on a cubic bezier curve. \a t is clamped between 0 and 1 
        </member>
        <member name="T:Pathfinding.VectorMath">
            Various vector math utility functions.
             \version A lot of functions in the Polygon class have been moved to this class
             the names have changed slightly and everything now consistently assumes a left handed
             coordinate system now instead of sometimes using a left handed one and sometimes
             using a right handed one. This is why the 'Left' methods in the Polygon class redirect
             to methods named 'Right'. The functionality is exactly the same.
            
             Note the difference between segments and lines. Lines are infinitely
             long but segments have only a finite length.
            
             \ingroup utils
        </member>
        <member name="M:Pathfinding.VectorMath.ClosestPointOnLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the closest point on the line.
            The line is treated as infinite.
            \see ClosestPointOnSegment
            \see ClosestPointOnLineFactor
        </member>
        <member name="M:Pathfinding.VectorMath.ClosestPointOnLineFactor(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Factor along the line which is closest to the point.
             Returned value is in the range [0,1] if the point lies on the segment otherwise it just lies on the line.
             The closest point can be calculated using (end-start)*factor + start.
            
             \see ClosestPointOnLine
             \see ClosestPointOnSegment
        </member>
        <member name="M:Pathfinding.VectorMath.ClosestPointOnLineFactor(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Factor along the line which is closest to the point.
            Returned value is in the range [0,1] if the point lies on the segment otherwise it just lies on the line.
            The closest point can be calculated using (end-start)*factor + start
        </member>
        <member name="M:Pathfinding.VectorMath.ClosestPointOnLineFactor(Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2)">
            Factor of the nearest point on the segment.
            Returned value is in the range [0,1] if the point lies on the segment otherwise it just lies on the line.
            The closest point can be calculated using (end-start)*factor + start;
        </member>
        <member name="M:Pathfinding.VectorMath.ClosestPointOnSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the closest point on the segment.
            The segment is NOT treated as infinite.
            \see ClosestPointOnLine
            \see ClosestPointOnSegmentXZ
        </member>
        <member name="M:Pathfinding.VectorMath.ClosestPointOnSegmentXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the closest point on the segment in the XZ plane.
             The y coordinate of the result will be the same as the y coordinate of the \a point parameter.
            
             The segment is NOT treated as infinite.
             \see ClosestPointOnSegment
             \see ClosestPointOnLine
        </member>
        <member name="M:Pathfinding.VectorMath.SqrDistancePointSegmentApproximate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            Returns the approximate shortest squared distance between x,z and the segment p-q.
            The segment is not considered infinite.
            This function is not entirely exact, but it is about twice as fast as DistancePointSegment2.
            \todo Is this actually approximate? It looks exact.
        </member>
        <member name="M:Pathfinding.VectorMath.SqrDistancePointSegmentApproximate(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns the approximate shortest squared distance between x,z and the segment p-q.
            The segment is not considered infinite.
            This function is not entirely exact, but it is about twice as fast as DistancePointSegment2.
            \todo Is this actually approximate? It looks exact.
        </member>
        <member name="M:Pathfinding.VectorMath.SqrDistancePointSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the squared distance between p and the segment a-b.
            The line is not considered infinite.
        </member>
        <member name="M:Pathfinding.VectorMath.SqrDistanceSegmentSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            3D minimum distance between 2 segments.
            Input: two 3D line segments S1 and S2
            \returns the shortest squared distance between S1 and S2
        </member>
        <member name="M:Pathfinding.VectorMath.SqrDistanceXZ(UnityEngine.Vector3,UnityEngine.Vector3)">
            Squared distance between two points in the XZ plane 
        </member>
        <member name="M:Pathfinding.VectorMath.SignedTriangleAreaTimes2XZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Signed area of a triangle in the XZ plane multiplied by 2.
            This will be negative for clockwise triangles and positive for counter-clockwise ones
        </member>
        <member name="M:Pathfinding.VectorMath.SignedTriangleAreaTimes2XZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Signed area of a triangle in the XZ plane multiplied by 2.
            This will be negative for clockwise triangles and positive for counter-clockwise ones.
        </member>
        <member name="M:Pathfinding.VectorMath.RightXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if \a p lies on the right side of the line \a a - \a b.
            Uses XZ space. Does not return true if the points are colinear.
        </member>
        <member name="M:Pathfinding.VectorMath.RightXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if \a p lies on the right side of the line \a a - \a b.
            Uses XZ space. Does not return true if the points are colinear.
        </member>
        <member name="M:Pathfinding.VectorMath.RightOrColinear(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            Returns if \a p lies on the right side of the line \a a - \a b.
            Also returns true if the points are colinear.
        </member>
        <member name="M:Pathfinding.VectorMath.RightOrColinear(Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2)">
            Returns if \a p lies on the right side of the line \a a - \a b.
            Also returns true if the points are colinear.
        </member>
        <member name="M:Pathfinding.VectorMath.RightOrColinearXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if \a p lies on the left side of the line \a a - \a b.
            Uses XZ space. Also returns true if the points are colinear.
        </member>
        <member name="M:Pathfinding.VectorMath.RightOrColinearXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if \a p lies on the left side of the line \a a - \a b.
            Uses XZ space. Also returns true if the points are colinear.
        </member>
        <member name="M:Pathfinding.VectorMath.IsClockwiseMarginXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the points a in a clockwise order.
            Will return true even if the points are colinear or very slightly counter-clockwise
            (if the signed area of the triangle formed by the points has an area less than or equals to float.Epsilon) 
        </member>
        <member name="M:Pathfinding.VectorMath.IsClockwiseXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the points a in a clockwise order 
        </member>
        <member name="M:Pathfinding.VectorMath.IsClockwiseXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the points a in a clockwise order 
        </member>
        <member name="M:Pathfinding.VectorMath.IsClockwiseOrColinearXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns true if the points a in a clockwise order or if they are colinear 
        </member>
        <member name="M:Pathfinding.VectorMath.IsClockwiseOrColinear(Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2)">
            Returns true if the points a in a clockwise order or if they are colinear 
        </member>
        <member name="M:Pathfinding.VectorMath.IsColinearXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the points are colinear (lie on a straight line) 
        </member>
        <member name="M:Pathfinding.VectorMath.IsColinearXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the points are colinear (lie on a straight line) 
        </member>
        <member name="M:Pathfinding.VectorMath.IsColinearAlmostXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the points are colinear (lie on a straight line) 
        </member>
        <member name="M:Pathfinding.VectorMath.SegmentsIntersect(Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2)">
            Returns if the line segment \a start2 - \a end2 intersects the line segment \a start1 - \a end1.
            If only the endpoints coincide, the result is undefined (may be true or false).
        </member>
        <member name="M:Pathfinding.VectorMath.SegmentsIntersectXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the line segment \a start2 - \a end2 intersects the line segment \a start1 - \a end1.
             If only the endpoints coincide, the result is undefined (may be true or false).
            
             \note XZ space
        </member>
        <member name="M:Pathfinding.VectorMath.SegmentsIntersectXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the two line segments intersects. The lines are NOT treated as infinite (just for clarification)
            \see IntersectionPoint
        </member>
        <member name="M:Pathfinding.VectorMath.LineDirIntersectionPointXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Intersection point between two infinite lines.
             Note that start points and directions are taken as parameters instead of start and end points.
             Lines are treated as infinite. If the lines are parallel 'start1' will be returned.
             Intersections are calculated on the XZ plane.
            
             \see LineIntersectionPointXZ
        </member>
        <member name="M:Pathfinding.VectorMath.LineDirIntersectionPointXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean@)">
            Intersection point between two infinite lines.
             Note that start points and directions are taken as parameters instead of start and end points.
             Lines are treated as infinite. If the lines are parallel 'start1' will be returned.
             Intersections are calculated on the XZ plane.
            
             \see LineIntersectionPointXZ
        </member>
        <member name="M:Pathfinding.VectorMath.RaySegmentIntersectXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the ray (start1, end1) intersects the segment (start2, end2).
            false is returned if the lines are parallel.
            Only the XZ coordinates are used.
            \todo Double check that this actually works
        </member>
        <member name="M:Pathfinding.VectorMath.LineIntersectionFactorXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,System.Single@,System.Single@)">
            Returns the intersection factors for line 1 and line 2. The intersection factors is a distance along the line \a start - \a end where the other line intersects it.\n
            \code intersectionPoint = start1 + factor1 * (end1-start1) \endcode
            \code intersectionPoint2 = start2 + factor2 * (end2-start2) \endcode
            Lines are treated as infinite.\n
            false is returned if the lines are parallel and true if they are not.
            Only the XZ coordinates are used.
        </member>
        <member name="M:Pathfinding.VectorMath.LineIntersectionFactorXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single@,System.Single@)">
            Returns the intersection factors for line 1 and line 2. The intersection factors is a distance along the line \a start - \a end where the other line intersects it.\n
            \code intersectionPoint = start1 + factor1 * (end1-start1) \endcode
            \code intersectionPoint2 = start2 + factor2 * (end2-start2) \endcode
            Lines are treated as infinite.\n
            false is returned if the lines are parallel and true if they are not.
            Only the XZ coordinates are used.
        </member>
        <member name="M:Pathfinding.VectorMath.LineRayIntersectionFactorXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns the intersection factor for line 1 with ray 2.
             The intersection factors is a factor distance along the line \a start - \a end where the other line intersects it.\n
             \code intersectionPoint = start1 + factor * (end1-start1) \endcode
             Lines are treated as infinite.\n
            
             The second "line" is treated as a ray, meaning only matches on start2 or forwards towards end2 (and beyond) will be returned
             If the point lies on the wrong side of the ray start, Nan will be returned.
            
             NaN is returned if the lines are parallel. 
        </member>
        <member name="M:Pathfinding.VectorMath.LineIntersectionFactorXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the intersection factor for line 1 with line 2.
            The intersection factor is a distance along the line \a start1 - \a end1 where the line \a start2 - \a end2 intersects it.\n
            \code intersectionPoint = start1 + intersectionFactor * (end1-start1) \endcode.
            Lines are treated as infinite.\n
            -1 is returned if the lines are parallel (note that this is a valid return value if they are not parallel too) 
        </member>
        <member name="M:Pathfinding.VectorMath.LineIntersectionPointXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the intersection point between the two lines. Lines are treated as infinite. \a start1 is returned if the lines are parallel 
        </member>
        <member name="M:Pathfinding.VectorMath.LineIntersectionPointXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean@)">
            Returns the intersection point between the two lines. Lines are treated as infinite. \a start1 is returned if the lines are parallel 
        </member>
        <member name="M:Pathfinding.VectorMath.LineIntersectionPoint(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            Returns the intersection point between the two lines. Lines are treated as infinite. \a start1 is returned if the lines are parallel 
        </member>
        <member name="M:Pathfinding.VectorMath.LineIntersectionPoint(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,System.Boolean@)">
            Returns the intersection point between the two lines. Lines are treated as infinite. \a start1 is returned if the lines are parallel 
        </member>
        <member name="M:Pathfinding.VectorMath.SegmentIntersectionPointXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean@)">
            Returns the intersection point between the two line segments in XZ space.
            Lines are NOT treated as infinite. \a start1 is returned if the line segments do not intersect
            The point will be returned along the line [start1, end1] (this matters only for the y coordinate).
        </member>
        <member name="M:Pathfinding.VectorMath.SegmentIntersectsBounds(UnityEngine.Bounds,UnityEngine.Vector3,UnityEngine.Vector3)">
            Does the line segment intersect the bounding box.
            The line is NOT treated as infinite.
            \author Slightly modified code from http://www.3dkingdoms.com/weekly/weekly.php?a=21
        </member>
        <member name="M:Pathfinding.VectorMath.ReversesFaceOrientations(UnityEngine.Matrix4x4)">
            True if the matrix will reverse orientations of faces.
            
             Scaling by a negative value along an odd number of axes will reverse
             the orientation of e.g faces on a mesh. This must be counter adjusted
             by for example the recast rasterization system to be able to handle
             meshes with negative scales properly.
            
             We can find out if they are flipped by finding out how the signed
             volume of a unit cube is transformed when applying the matrix
            
             If the (signed) volume turns out to be negative
             that also means that the orientation of it has been reversed.
            
             \see https://en.wikipedia.org/wiki/Normal_(geometry)
             \see https://en.wikipedia.org/wiki/Parallelepiped
        </member>
        <member name="T:Pathfinding.AstarMath">
            Utility functions for working with numbers and strings.
            \ingroup utils
            \see Polygon
            \see VectorMath
        </member>
        <member name="M:Pathfinding.AstarMath.NearestPoint(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the closest point on the line. The line is treated as infinite.
            \see NearestPointStrict
        </member>
        <member name="M:Pathfinding.AstarMath.NearestPointFactor(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Factor of the nearest point on the segment.
            Returned value is in the range [0,1] if the point lies on the segment otherwise it just lies on the line.
            The closest point can be got by (end-start)*factor + start;
        </member>
        <member name="M:Pathfinding.AstarMath.NearestPointFactor(Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2)">
            Factor of the nearest point on the segment.
            Returned value is in the range [0,1] if the point lies on the segment otherwise it just lies on the line.
            The closest point can be got by (end-start)*factor + start;
        </member>
        <member name="M:Pathfinding.AstarMath.NearestPointStrict(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the closest point on the line segment. The line is NOT treated as infinite.
            \see NearestPoint
        </member>
        <member name="M:Pathfinding.AstarMath.NearestPointStrictXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the closest point on the line segment on the XZ plane. The line is NOT treated as infinite.
            \see NearestPoint
        </member>
        <member name="M:Pathfinding.AstarMath.DistancePointSegment(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            Returns the approximate shortest squared distance between x,z and the line p-q.
            The line is considered infinite.
            This function is not entirely exact, but it is about twice as fast as DistancePointSegment2.
        </member>
        <member name="M:Pathfinding.AstarMath.DistancePointSegment(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns the approximate shortest squared distance between x,z and the line p-q.
            The line is considered infinite.
            This function is not entirely exact, but it is about twice as fast as DistancePointSegment2.
        </member>
        <member name="M:Pathfinding.AstarMath.DistancePointSegmentStrict(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the squared distance between c and the line a-b. The line is not considered infinite. 
        </member>
        <member name="M:Pathfinding.AstarMath.CubicBezier(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            Returns a point on a cubic bezier curve. \a t is clamped between 0 and 1 
        </member>
        <member name="M:Pathfinding.AstarMath.MapTo(System.Single,System.Single,System.Single)">
            Maps a value between startMin and startMax to be between 0 and 1 
        </member>
        <member name="M:Pathfinding.AstarMath.MapTo(System.Single,System.Single,System.Single,System.Single,System.Single)">
            Maps a value between startMin and startMax to be between targetMin and targetMax 
        </member>
        <member name="M:Pathfinding.AstarMath.FormatBytesBinary(System.Int32)">
            Returns a nicely formatted string for the number of bytes (KiB, MiB, GiB etc). Uses decimal names (KB, Mb - 1000) but calculates using binary values (KiB, MiB - 1024) 
        </member>
        <!-- Badly formed XML comment ignored for member "M:Pathfinding.AstarMath.Bit(System.Int32,System.Int32)" -->
        <member name="M:Pathfinding.AstarMath.IntToColor(System.Int32,System.Single)">
            Returns a nice color from int \a i with alpha \a a. Got code from the open-source Recast project, works really well\n
            Seems like there are only 64 possible colors from studying the code
        </member>
        <member name="M:Pathfinding.AstarMath.SqrMagnitudeXZ(UnityEngine.Vector3,UnityEngine.Vector3)">
            Squared distance between two points on the XZ plane 
        </member>
        <member name="M:Pathfinding.AstarMath.DistancePointSegment2(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            \deprecated Obsolete 
        </member>
        <member name="M:Pathfinding.AstarMath.DistancePointSegment2(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            \deprecated Obsolete 
        </member>
        <member name="M:Pathfinding.AstarMath.ComputeVertexHash(System.Int32,System.Int32,System.Int32)">
            \deprecated Use Int3.GetHashCode instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Hermite(System.Single,System.Single,System.Single)">
            \deprecated Obsolete 
        </member>
        <member name="M:Pathfinding.AstarMath.MapToRange(System.Single,System.Single,System.Single)">
            \deprecated Obsolete 
        </member>
        <member name="M:Pathfinding.AstarMath.FormatBytes(System.Int32)">
            \deprecated Obsolete 
        </member>
        <member name="M:Pathfinding.AstarMath.MagnitudeXZ(UnityEngine.Vector3,UnityEngine.Vector3)">
            \deprecated Obsolete 
        </member>
        <member name="M:Pathfinding.AstarMath.Repeat(System.Int32,System.Int32)">
            \deprecated Obsolete 
        </member>
        <member name="M:Pathfinding.AstarMath.Abs(System.Single)">
            \deprecated Use Mathf.Abs instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Abs(System.Int32)">
            \deprecated Use Mathf.Abs instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Min(System.Single,System.Single)">
            \deprecated Use Mathf.Min instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Min(System.Int32,System.Int32)">
            \deprecated Use Mathf.Min instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Min(System.UInt32,System.UInt32)">
            \deprecated Use Mathf.Min instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Max(System.Single,System.Single)">
            \deprecated Use Mathf.Max instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Max(System.Int32,System.Int32)">
            \deprecated Use Mathf.Max instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Max(System.UInt32,System.UInt32)">
            \deprecated Use Mathf.Max instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Max(System.UInt16,System.UInt16)">
            \deprecated Use Mathf.Max instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Sign(System.Single)">
            \deprecated Use Mathf.Sign instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Sign(System.Int32)">
            \deprecated Use Mathf.Sign instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Clamp(System.Single,System.Single,System.Single)">
            \deprecated Use Mathf.Clamp instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Clamp(System.Int32,System.Int32,System.Int32)">
            \deprecated Use Mathf.Clamp instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Clamp01(System.Single)">
            \deprecated Use Mathf.Clamp01 instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Clamp01(System.Int32)">
            \deprecated Use Mathf.Clamp01 instead 
        </member>
        <member name="M:Pathfinding.AstarMath.Lerp(System.Single,System.Single,System.Single)">
            \deprecated Use Mathf.Lerp instead 
        </member>
        <member name="M:Pathfinding.AstarMath.RoundToInt(System.Single)">
            \deprecated Use Mathf.RoundToInt instead 
        </member>
        <member name="M:Pathfinding.AstarMath.RoundToInt(System.Double)">
            \deprecated Use Mathf.RoundToInt instead 
        </member>
        <member name="T:Pathfinding.Polygon">
            Utility functions for working with polygons, lines, and other vector math.
             All functions which accepts Vector3s but work in 2D space uses the XZ space if nothing else is said.
            
             \version A lot of functions in this class have been moved to the VectorMath class
             the names have changed slightly and everything now consistently assumes a left handed
             coordinate system now instead of sometimes using a left handed one and sometimes
             using a right handed one. This is why the 'Left' methods redirect to methods
             named 'Right'. The functionality is exactly the same.
            
             \ingroup utils
        </member>
        <member name="M:Pathfinding.Polygon.TriangleArea2(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Signed area of a triangle in the XZ plane multiplied by 2.
            This will be negative for clockwise triangles and positive for counter-clockwise ones 
        </member>
        <member name="M:Pathfinding.Polygon.TriangleArea2(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Signed area of a triangle in the XZ plane multiplied by 2.
            This will be negative for clockwise triangles and positive for counter-clockwise ones.
        </member>
        <member name="M:Pathfinding.Polygon.TriangleArea(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Signed area of a triangle in the XZ plane multiplied by 2.
            This will be negative for clockwise triangles and positive for counter-clockwise ones.
            This method can handle larger numbers than TriangleArea2(Int3)
        </member>
        <member name="M:Pathfinding.Polygon.TriangleArea(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Signed area of a triangle in the XZ plane multiplied by 2.
            This will be negative for clockwise triangles and positive for counter-clockwise ones.
            Idential to TriangleArea2(Vector3), kept for compability.
        </member>
        <member name="M:Pathfinding.Polygon.ContainsPoint(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the triangle \a ABC contains the point \a p in XZ space 
        </member>
        <member name="M:Pathfinding.Polygon.ContainsPointXZ(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the triangle \a ABC contains the point \a p in XZ space.
            The triangle vertices are assumed to be laid out in clockwise order.
        </member>
        <member name="M:Pathfinding.Polygon.ContainsPoint(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the triangle \a ABC contains the point \a p 
        </member>
        <member name="M:Pathfinding.Polygon.ContainsPointXZ(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the triangle \a ABC contains the point \a p.
            The triangle vertices are assumed to be laid out in clockwise order.
        </member>
        <member name="M:Pathfinding.Polygon.ContainsPoint(Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2)">
            Returns if the triangle \a ABC contains the point \a p.
            The triangle vertices are assumed to be laid out in clockwise order.
        </member>
        <member name="M:Pathfinding.Polygon.ContainsPoint(UnityEngine.Vector3[],UnityEngine.Vector3)">
            Checks if \a p is inside the polygon (XZ space)
            \author http://unifycommunity.com/wiki/index.php?title=PolyContainsPoint (Eric5h5)
        </member>
        <member name="M:Pathfinding.Polygon.ContainsPoint(UnityEngine.Vector2[],UnityEngine.Vector2)">
            Checks if \a p is inside the polygon.
            \author http://unifycommunity.com/wiki/index.php?title=PolyContainsPoint (Eric5h5)
        </member>
        <member name="M:Pathfinding.Polygon.ContainsPointXZ(UnityEngine.Vector3[],UnityEngine.Vector3)">
            Checks if \a p is inside the polygon (XZ space).
            \author http://unifycommunity.com/wiki/index.php?title=PolyContainsPoint (Eric5h5)
        </member>
        <member name="M:Pathfinding.Polygon.LeftNotColinear(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if \a p lies on the left side of the line \a a - \a b. Uses XZ space.
            Does not return true if the points are colinear.
            \deprecated Use VectorMath.RightXZ instead. Note that it now uses a left handed coordinate system (same as Unity)
        </member>
        <member name="M:Pathfinding.Polygon.Left(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if \a p lies on the left side of the line \a a - \a b. Uses XZ space. Also returns true if the points are colinear
            \deprecated Use VectorMath.RightOrColinearXZ instead. Note that it now uses a left handed coordinate system (same as Unity)
        </member>
        <member name="M:Pathfinding.Polygon.Left(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            Returns if \a p lies on the left side of the line \a a - \a b. Also returns true if the points are colinear
            \deprecated Use VectorMath.RightOrColinear instead. Note that it now uses a left handed coordinate system (same as Unity)
        </member>
        <member name="M:Pathfinding.Polygon.Left(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if \a p lies on the left side of the line \a a - \a b. Uses XZ space. Also returns true if the points are colinear
            \deprecated Use VectorMath.RightOrColinearXZ instead. Note that it now uses a left handed coordinate system (same as Unity)
        </member>
        <member name="M:Pathfinding.Polygon.LeftNotColinear(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if \a p lies on the left side of the line \a a - \a b. Uses XZ space.
            \deprecated Use VectorMath.RightXZ instead. Note that it now uses a left handed coordinate system (same as Unity)
        </member>
        <member name="M:Pathfinding.Polygon.Left(Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2)">
            Returns if \a p lies on the left side of the line \a a - \a b. Also returns true if the points are colinear
            \deprecated Use VectorMath.RightOrColinear instead. Note that it now uses a left handed coordinate system (same as Unity)
        </member>
        <member name="M:Pathfinding.Polygon.IsClockwiseMargin(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the points a in a clockwise order.
            Will return true even if the points are colinear or very slightly counter-clockwise
            (if the signed area of the triangle formed by the points has an area less than or equals to float.Epsilon)
            \deprecated Use VectorMath.IsClockwiseMarginXZ instead
        </member>
        <member name="M:Pathfinding.Polygon.IsClockwise(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the points a in a clockwise order
            \deprecated Use VectorMath.IsClockwiseXZ instead
        </member>
        <member name="M:Pathfinding.Polygon.IsClockwise(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the points a in a clockwise order
            \deprecated Use VectorMath.IsClockwiseXZ instead
        </member>
        <member name="M:Pathfinding.Polygon.IsClockwiseMargin(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns true if the points a in a clockwise order or if they are colinear
            \deprecated Use VectorMath.IsClockwiseOrColinearXZ instead
        </member>
        <member name="M:Pathfinding.Polygon.IsClockwiseMargin(Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2)">
            Returns true if the points a in a clockwise order or if they are colinear
            \deprecated Use VectorMath.IsClockwiseOrColinear instead
        </member>
        <member name="M:Pathfinding.Polygon.IsColinear(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the points are colinear (lie on a straight line)
            \deprecated Use VectorMath.IsColinearXZ instead
        </member>
        <member name="M:Pathfinding.Polygon.IsColinearAlmost(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the points are colinear (lie on a straight line)
            \deprecated Use VectorMath.IsColinearAlmostXZ instead
        </member>
        <member name="M:Pathfinding.Polygon.IsColinear(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the points are colinear (lie on a straight line)
            \deprecated Use VectorMath.IsColinearXZ instead
        </member>
        <member name="M:Pathfinding.Polygon.IntersectsUnclamped(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the line segment \a a2 - \a b2 intersects the infinite line \a a - \a b. a-b is infinite, a2-b2 is not infinite 
        </member>
        <member name="M:Pathfinding.Polygon.Intersects(Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2,Pathfinding.Int2)">
            Returns if the line segment \a a2 - \a b2 intersects the line segment \a a - \a b.
             If only the endpoints coincide, the result is undefined (may be true or false).
            
             \deprecated Use VectorMath.SegmentsIntersect instead 
        </member>
        <member name="M:Pathfinding.Polygon.Intersects(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the line segment \a a2 - \a b2 intersects the line segment \a a - \a b.
             If only the endpoints coincide, the result is undefined (may be true or false).
            
             \note XZ space
            
             \deprecated Use VectorMath.SegmentsIntersectXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.Intersects(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns if the two line segments intersects. The lines are NOT treated as infinite (just for clarification)
             \see IntersectionPoint
            
             \deprecated Use VectorMath.SegmentsIntersectXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionPointOptimized(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Intersection point between two infinite lines.
             Lines are treated as infinite. If the lines are parallel 'start1' will be returned. Intersections are calculated on the XZ plane.
            
             \deprecated Use VectorMath.LineDirIntersectionPointXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionPointOptimized(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean@)">
            Intersection point between two infinite lines.
             Lines are treated as infinite. If the lines are parallel 'start1' will be returned. Intersections are calculated on the XZ plane.
            
             \deprecated Use VectorMath.LineDirIntersectionPointXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionFactorRaySegment(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns if the ray (start1, end1) intersects the segment (start2, end2).
             false is returned if the lines are parallel.
             Only the XZ coordinates are used.
             \todo Double check that this actually works
            
             \deprecated Use VectorMath.RaySegmentIntersectXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionFactor(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,System.Single@,System.Single@)">
            Returns the intersection factors for line 1 and line 2. The intersection factors is a distance along the line \a start - \a end where the other line intersects it.\n
             \code intersectionPoint = start1 + factor1 * (end1-start1) \endcode
             \code intersectionPoint2 = start2 + factor2 * (end2-start2) \endcode
             Lines are treated as infinite.\n
             false is returned if the lines are parallel and true if they are not.
             Only the XZ coordinates are used.
            
             \deprecated Use VectorMath.LineIntersectionFactorXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionFactor(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single@,System.Single@)">
            Returns the intersection factors for line 1 and line 2. The intersection factors is a distance along the line \a start - \a end where the other line intersects it.\n
             \code intersectionPoint = start1 + factor1 * (end1-start1) \endcode
             \code intersectionPoint2 = start2 + factor2 * (end2-start2) \endcode
             Lines are treated as infinite.\n
             false is returned if the lines are parallel and true if they are not.
             Only the XZ coordinates are used.
            
             \deprecated Use VectorMath.LineIntersectionFactorXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionFactorRay(Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3,Pathfinding.Int3)">
            Returns the intersection factor for line 1 with ray 2.
             The intersection factors is a factor distance along the line \a start - \a end where the other line intersects it.\n
             \code intersectionPoint = start1 + factor * (end1-start1) \endcode
             Lines are treated as infinite.\n
            
             The second "line" is treated as a ray, meaning only matches on start2 or forwards towards end2 (and beyond) will be returned
             If the point lies on the wrong side of the ray start, Nan will be returned.
            
             NaN is returned if the lines are parallel. *
             \deprecated Use VectorMath.LineRayIntersectionFactorXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionFactor(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the intersection factor for line 1 with line 2.
            The intersection factor is a distance along the line \a start1 - \a end1 where the line \a start2 - \a end2 intersects it.\n
            \code intersectionPoint = start1 + intersectionFactor * (end1-start1) \endcode.
            Lines are treated as infinite.\n
            -1 is returned if the lines are parallel (note that this is a valid return value if they are not parallel too) *
            \deprecated Use VectorMath.LineIntersectionFactorXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionPoint(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the intersection point between the two lines. Lines are treated as infinite. \a start1 is returned if the lines are parallel
            \deprecated Use VectorMath.LineIntersectionPointXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionPoint(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean@)">
            Returns the intersection point between the two lines. Lines are treated as infinite. \a start1 is returned if the lines are parallel
            \deprecated Use VectorMath.LineIntersectionPointXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionPoint(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            Returns the intersection point between the two lines. Lines are treated as infinite. \a start1 is returned if the lines are parallel
            \deprecated Use VectorMath.LineIntersectionPoint instead 
        </member>
        <member name="M:Pathfinding.Polygon.IntersectionPoint(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,System.Boolean@)">
            Returns the intersection point between the two lines. Lines are treated as infinite. \a start1 is returned if the lines are parallel
            \deprecated Use VectorMath.LineIntersectionPoint instead 
        </member>
        <member name="M:Pathfinding.Polygon.SegmentIntersectionPoint(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean@)">
            Returns the intersection point between the two line segments in XZ space.
             Lines are NOT treated as infinite. \a start1 is returned if the line segments do not intersect
             The point will be returned along the line [start1, end1] (this matters only for the y coordinate).
            
             \deprecated Use VectorMath.SegmentIntersectionPointXZ instead 
        </member>
        <member name="M:Pathfinding.Polygon.ConvexHull(UnityEngine.Vector3[])">
            Calculates convex hull in XZ space for the points.
             Implemented using the very simple Gift Wrapping Algorithm
             which has a complexity of O(nh) where \a n is the number of points and \a h is the number of points on the hull,
             so it is in the worst case quadratic.
            
             \deprecated Use ConvexHullXZ instead
        </member>
        <member name="M:Pathfinding.Polygon.ConvexHullXZ(UnityEngine.Vector3[])">
            Calculates convex hull in XZ space for the points.
            Implemented using the very simple Gift Wrapping Algorithm
            which has a complexity of O(nh) where \a n is the number of points and \a h is the number of points on the hull,
            so it is in the worst case quadratic.
        </member>
        <member name="M:Pathfinding.Polygon.LineIntersectsBounds(UnityEngine.Bounds,UnityEngine.Vector3,UnityEngine.Vector3)">
            Does the line segment intersect the bounding box.
             The line is NOT treated as infinite.
             \author Slightly modified code from http://www.3dkingdoms.com/weekly/weekly.php?a=21
            
             \deprecated Use VectorMath.SegmentIntersectsBounds instead
        </member>
        <member name="M:Pathfinding.Polygon.Subdivide(UnityEngine.Vector3[],System.Int32)">
            Subdivides \a path and returns the new array with interpolated values.
            The returned array is \a path subdivided \a subdivisions times, the resulting points are interpolated using Mathf.SmoothStep.\n
            If \a subdivisions is less or equal to 0 (zero), the original array will be returned 
        </member>
        <member name="M:Pathfinding.Polygon.ClosestPointOnTriangle(UnityEngine.Vector3[],UnityEngine.Vector3)">
            Returns the closest point on the triangle. The \a triangle array must have a length of at least 3.
             \see ClosesPointOnTriangle(Vector3,Vector3,Vector3,Vector3);
            
             \deprecated Scheduled for removal since it is not used by any part of the A* Pathfinding Project
        </member>
        <member name="M:Pathfinding.Polygon.ClosestPointOnTriangle(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Returns the closest point on the triangle.
            
             \author Got code from the internet, changed a bit to work with the Unity API
            
        </member>
        <member name="M:Pathfinding.Polygon.DistanceSegmentSegment3D(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            Get the 3D minimum distance between 2 segments
             Input:  two 3D line segments S1 and S2
             \returns the shortest squared distance between S1 and S2
            
             \deprecated Use VectorMath.SqrDistanceSegmentSegment instead
        </member>
        <member name="F:Pathfinding.GraphUpdateScene.points">
            Points which define the region to update 
        </member>
        <member name="F:Pathfinding.GraphUpdateScene.convexPoints">
            Private cached convex hull of the #points 
        </member>
        <member name="F:Pathfinding.GraphUpdateScene.useWorldSpace">
            Use world space for coordinates.
             If true, the shape will not follow when moving around the transform.
            
             \see #ToggleUseWorldSpace
        </member>
        <member name="F:Pathfinding.GraphUpdateScene.updatePhysics">
            Update node's walkability and connectivity using physics functions.
             For grid graphs, this will update the node's position and walkability exactly like when doing a scan of the graph.
             If enabled for grid graphs, #modifyWalkability will be ignored.
            
             For Point Graphs, this will recalculate all connections which passes through the bounds of the resulting Graph Update Object
             using raycasts (if enabled).
            
        </member>
        <member name="F:Pathfinding.GraphUpdateScene.resetPenaltyOnPhysics">
            \copydoc Pathfinding::GraphUpdateObject::resetPenaltyOnPhysics 
        </member>
        <member name="F:Pathfinding.GraphUpdateScene.updateErosion">
            \copydoc Pathfinding::GraphUpdateObject::updateErosion 
        </member>
        <member name="F:Pathfinding.GraphUpdateScene.setTagInvert">
            Private cached inversion of #setTag.
            Used for InvertSettings() 
        </member>
        <member name="F:Pathfinding.GraphUpdateScene.firstApplied">
            Has apply been called yet.
            Used to prevent applying twice when both applyOnScan and applyOnStart are enabled 
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.Start">
            Do some stuff at start 
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.InvertSettings">
            Inverts all invertable settings for this GUS.
             Namely: penalty delta, walkability, tags.
            
             Penalty delta will be changed to negative penalty delta.\n
             #setWalkability will be inverted.\n
             #setTag will be stored in a private variable, and the new value will be 0. When calling this function again, the saved
             value will be the new value.
            
             Calling this function an even number of times without changing any settings in between will be identical to no change in settings.
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.RecalcConvex">
            Recalculate convex points.
            Will not do anything if not #convex is enabled
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.ToggleUseWorldSpace">
            Switches between using world space and using local space.
             Changes point coordinates to stay the same in world space after the change.
            
             \see #useWorldSpace
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.LockToY">
            Lock all points to a specific Y value.
            
             \see lockToYValue
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.Apply(AstarPath)">
            Apply the update.
            Will only do anything if #applyOnScan is enabled 
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.GetBounds">
            Calculates the bounds for this component.
            This is a relatively expensive operation, it needs to go through all points and
            sometimes do matrix multiplications.
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.Apply">
            Updates graphs with a created GUO.
            Creates a Pathfinding.GraphUpdateObject with a Pathfinding.GraphUpdateShape
            representing the polygon of this object and update all graphs using AstarPath.UpdateGraphs.
            This will not update graphs directly. See AstarPath.UpdateGraph for more info.
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.OnDrawGizmos">
            Draws some gizmos 
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.OnDrawGizmosSelected">
            Draws some gizmos 
        </member>
        <member name="M:Pathfinding.GraphUpdateScene.OnDrawGizmos(System.Boolean)">
            Draws some gizmos 
        </member>
        <member name="T:Pathfinding.GraphUpdateShape">
            Defines a shape for a Pathfinding.GraphUpdateObject.
            The shape consists of a number of points which it can either calculate the convex hull of (XZ space) or use as a polygon directly.
            \see Pathfinding.GraphUpdateObject.shape
        </member>
        <member name="P:Pathfinding.GraphUpdateShape.points">
            Gets or sets the points of the polygon in the shape.
            Will automatically calculate the convex hull if #convex is set to true 
        </member>
        <member name="P:Pathfinding.GraphUpdateShape.convex">
            Sets if the convex hull of the points should be calculated.
            Convex hulls are faster but non-convex hulls can be used to specify the shape more exactly
        </member>
        <member name="T:Pathfinding.AstarEnumFlagAttribute">
            \author http://wiki.unity3d.com/index.php/EnumFlagPropertyDrawer 
        </member>
        <member name="T:Pathfinding.BinaryHeapM">
            Binary heap implementation.
             Binary heaps are really fast for ordering nodes in a way that
             makes it possible to get the node with the lowest F score.
             Also known as a priority queue.
            
             This has actually been rewritten as a d-ary heap (by default a 4-ary heap)
             for performance, but it's the same principle.
            
             \see http://en.wikipedia.org/wiki/Binary_heap
             \see https://en.wikipedia.org/wiki/D-ary_heap
        </member>
        <member name="F:Pathfinding.BinaryHeapM.numberOfItems">
            Number of items in the tree 
        </member>
        <member name="F:Pathfinding.BinaryHeapM.growthFactor">
            The tree will grow by at least this factor every time it is expanded 
        </member>
        <member name="F:Pathfinding.BinaryHeapM.D">
            Number of children of each node in the tree.
            Different values have been tested and 4 has been empirically found to perform the best.
            \see https://en.wikipedia.org/wiki/D-ary_heap
        </member>
        <member name="F:Pathfinding.BinaryHeapM.SortGScores">
            Sort nodes by G score if there is a tie when comparing the F score 
        </member>
        <member name="F:Pathfinding.BinaryHeapM.binaryHeap">
            Internal backing array for the tree 
        </member>
        <member name="M:Pathfinding.BinaryHeapM.Add(Pathfinding.PathNode)">
            Adds a node to the heap 
        </member>
        <member name="M:Pathfinding.BinaryHeapM.Remove">
            Returns the node with the lowest F score from the heap 
        </member>
        <member name="M:Pathfinding.BinaryHeapM.Rebuild">
            Rebuilds the heap by trickeling down all items.
            Usually called after the hTarget on a path has been changed 
        </member>
        <member name="F:Pathfinding.GraphEditorBase.target">
            NavGraph this editor is exposing 
        </member>
        <member name="T:Pathfinding.GraphModifier">
            GraphModifier for modifying graphs or processing graph data based on events.
             This class is a simple container for a number of events.
            
             \warning Some events will be called both in play mode <b>and in editor mode</b> (at least the scan events).
             So make sure your code handles both cases well. You may choose to ignore editor events.
             \see Application.IsPlaying
        </member>
        <member name="F:Pathfinding.GraphModifier.root">
            All active graph modifiers 
        </member>
        <member name="T:Pathfinding.GraphModifier.EventType">
            GraphModifier event type.
            \see GraphModifier 
        </member>
        <member name="M:Pathfinding.GraphModifier.TriggerEvent(Pathfinding.GraphModifier.EventType)">
            Triggers an event for all active graph modifiers 
        </member>
        <member name="M:Pathfinding.GraphModifier.OnEnable">
            Adds this modifier to list of active modifiers.
        </member>
        <member name="M:Pathfinding.GraphModifier.OnDisable">
            Removes this modifier from list of active modifiers 
        </member>
        <member name="M:Pathfinding.GraphModifier.OnPostScan">
            Called right after all graphs have been scanned.
             FloodFill and other post processing has not been done.
            
             \warning Since OnEnable and Awake are called roughly in the same time, the only way
             to ensure that these scripts get this call when scanning in Awake is to
             set the Script Execution Order for AstarPath to some time later than default time
             (see Edit -> Project Settings -> Script Execution Order).
            
             \see OnLatePostScan
        </member>
        <member name="M:Pathfinding.GraphModifier.OnPreScan">
            Called right before graphs are going to be scanned.
            
             \warning Since OnEnable and Awake are called roughly in the same time, the only way
             to ensure that these scripts get this call when scanning in Awake is to
             set the Script Execution Order for AstarPath to some time later than default time
             (see Edit -> Project Settings -> Script Execution Order).
            
             \see OnLatePostScan
             
        </member>
        <member name="M:Pathfinding.GraphModifier.OnLatePostScan">
            Called at the end of the scanning procedure.
             This is the absolute last thing done by Scan.
            
             \note This event will be called even if Script Execution Order has messed things up
             (see the other two scan events).
        </member>
        <member name="M:Pathfinding.GraphModifier.OnPostCacheLoad">
            Called after cached graphs have been loaded.
             When using cached startup, this event is analogous to OnLatePostScan and implementing scripts
             should do roughly the same thing for both events.
            
             \note This event will be called even if Script Execution Order has messed things up
             (see the other two scan events).
        </member>
        <member name="M:Pathfinding.GraphModifier.OnGraphsPreUpdate">
            Called before graphs are updated using GraphUpdateObjects 
        </member>
        <member name="M:Pathfinding.GraphModifier.OnGraphsPostUpdate">
            Called after graphs have been updated using GraphUpdateObjects.
            Eventual flood filling has been done 
        </member>
        <member name="T:Pathfinding.Int3">
            Holds a coordinate in integers 
        </member>
        <member name="F:Pathfinding.Int3.Precision">
            Precision for the integer coordinates.
            One world unit is divided into [value] pieces. A value of 1000 would mean millimeter precision, a value of 1 would mean meter precision (assuming 1 world unit = 1 meter).
            This value affects the maximum coordinates for nodes as well as how large the cost values are for moving between two nodes.
            A higher value means that you also have to set all penalty values to a higher value to compensate since the normal cost of moving will be higher.
        </member>
        <member name="F:Pathfinding.Int3.FloatPrecision">
            #Precision as a float 
        </member>
        <member name="F:Pathfinding.Int3.PrecisionFactor">
            1 divided by #Precision 
        </member>
        <member name="M:Pathfinding.Int3.Angle(Pathfinding.Int3,Pathfinding.Int3)">
            Angle between the vectors in radians 
        </member>
        <member name="M:Pathfinding.Int3.Normal2D">
            Normal in 2D space (XZ).
            Equivalent to Cross(this, Int3(0,1,0) )
            except that the Y coordinate is left unchanged with this operation.
        </member>
        <member name="P:Pathfinding.Int3.magnitude">
            Returns the magnitude of the vector. The magnitude is the 'length' of the vector from 0,0,0 to this point. Can be used for distance calculations:
            \code Debug.Log ("Distance between 3,4,5 and 6,7,8 is: "+(new Int3(3,4,5) - new Int3(6,7,8)).magnitude); \endcode
        </member>
        <member name="P:Pathfinding.Int3.costMagnitude">
            Magnitude used for the cost between two nodes. The default cost between two nodes can be calculated like this:
             \code int cost = (node1.position-node2.position).costMagnitude; \endcode
            
             This is simply the magnitude, rounded to the nearest integer
        </member>
        <member name="P:Pathfinding.Int3.worldMagnitude">
            The magnitude in world units.
            \deprecated This property is deprecated. Use magnitude or cast to a Vector3
        </member>
        <member name="P:Pathfinding.Int3.sqrMagnitude">
            The squared magnitude of the vector 
        </member>
        <member name="P:Pathfinding.Int3.sqrMagnitudeLong">
            The squared magnitude of the vector 
        </member>
        <member name="M:Pathfinding.Int3.ToString">
            Returns a nicely formatted string representing the vector 
        </member>
        <member name="T:Pathfinding.Int2">
            Two Dimensional Integer Coordinate Pair 
        </member>
        <member name="M:Pathfinding.Int2.DotLong(Pathfinding.Int2,Pathfinding.Int2)">
            Dot product of the two coordinates 
        </member>
        <member name="F:Pathfinding.Int2.Rotations">
            Matrices for rotation.
            Each group of 4 elements is a 2x2 matrix.
            The XZ position is multiplied by this.
            So
            \code
            //A rotation by 90 degrees clockwise, second matrix in the array
            (5,2) * ((0, 1), (-1, 0)) = (2,-5)
            \endcode
        </member>
        <member name="M:Pathfinding.Int2.Rotate(Pathfinding.Int2,System.Int32)">
            Returns a new Int2 rotated 90*r degrees around the origin.
            \deprecated Deprecated becuase it is not used by any part of the A* Pathfinding Project
        </member>
        <!-- Badly formed XML comment ignored for member "T:Pathfinding.Util.ListPool`1" -->
        <member name="F:Pathfinding.Util.ListPool`1.pool">
            Internal pool 
        </member>
        <member name="F:Pathfinding.Util.ListPool`1.MaxCapacitySearchLength">
            When requesting a list with a specified capacity, search max this many lists in the pool before giving up.
            Must be greater or equal to one.
        </member>
        <member name="M:Pathfinding.Util.ListPool`1.Claim">
            Claim a list.
            Returns a pooled list if any are in the pool.
            Otherwise it creates a new one.
            After usage, this list should be released using the Release function (though not strictly necessary).
        </member>
        <member name="M:Pathfinding.Util.ListPool`1.Claim(System.Int32)">
            Claim a list with minimum capacity
            Returns a pooled list if any are in the pool.
            Otherwise it creates a new one.
            After usage, this list should be released using the Release function (though not strictly necessary).
            This list returned will have at least the capacity specified.
        </member>
        <member name="M:Pathfinding.Util.ListPool`1.Warmup(System.Int32,System.Int32)">
            Makes sure the pool contains at least \a count pooled items with capacity \a size.
            This is good if you want to do all allocations at start.
        </member>
        <member name="M:Pathfinding.Util.ListPool`1.Release(System.Collections.Generic.List{`0})">
            Releases a list.
             After the list has been released it should not be used anymore.
            
             \throws System.InvalidOperationException
             Releasing a list when it has already been released will cause an exception to be thrown.
            
             \see Claim
        </member>
        <member name="M:Pathfinding.Util.ListPool`1.Clear">
            Clears the pool for lists of this type.
            This is an O(n) operation, where n is the number of pooled lists.
        </member>
        <member name="M:Pathfinding.Util.ListPool`1.GetSize">
            Number of lists of this type in the pool 
        </member>
        <!-- Badly formed XML comment ignored for member "T:Pathfinding.Util.ObjectPool`1" -->
        <member name="F:Pathfinding.Util.ObjectPool`1.pool">
            Internal pool 
        </member>
        <member name="M:Pathfinding.Util.ObjectPool`1.#cctor">
            Static constructor initializing the internal pool list 
        </member>
        <member name="M:Pathfinding.Util.ObjectPool`1.Claim">
            Claim a object.
            Returns a pooled object if any are in the pool.
            Otherwise it creates a new one.
            After usage, this object should be released using the Release function (though not strictly necessary).
        </member>
        <member name="M:Pathfinding.Util.ObjectPool`1.Warmup(System.Int32)">
            Makes sure the pool contains at least \a count pooled items with capacity \a size.
            This is good if you want to do all allocations at start.
        </member>
        <member name="M:Pathfinding.Util.ObjectPool`1.Release(`0)">
            Releases an object.
             After the object has been released it should not be used anymore.
            
             \throws System.InvalidOperationException
             Releasing an object when it has already been released will cause an exception to be thrown.
             However enabling ASTAR_OPTIMIZE_POOLING will prevent this check, making this function an O(1) operation instead of O(n).
            
             \see Claim
        </member>
        <member name="M:Pathfinding.Util.ObjectPool`1.Clear">
            Clears the pool for objects of this type.
            This is an O(n) operation, where n is the number of pooled objects.
        </member>
        <member name="M:Pathfinding.Util.ObjectPool`1.GetSize">
            Number of objects of this type in the pool 
        </member>
        <!-- Badly formed XML comment ignored for member "T:Pathfinding.Util.StackPool`1" -->
        <member name="F:Pathfinding.Util.StackPool`1.pool">
            Internal pool 
        </member>
        <member name="M:Pathfinding.Util.StackPool`1.#cctor">
            Static constructor 
        </member>
        <member name="M:Pathfinding.Util.StackPool`1.Claim">
            Claim a stack.
            Returns a pooled stack if any are in the pool.
            Otherwise it creates a new one.
            After usage, this stack should be released using the Release function (though not strictly necessary).
        </member>
        <member name="M:Pathfinding.Util.StackPool`1.Warmup(System.Int32)">
            Makes sure the pool contains at least \a count pooled items.
            This is good if you want to do all allocations at start.
        </member>
        <member name="M:Pathfinding.Util.StackPool`1.Release(System.Collections.Generic.Stack{`0})">
            Releases a stack.
            After the stack has been released it should not be used anymore.
            Releasing a stack twice will cause an error.
        </member>
        <member name="M:Pathfinding.Util.StackPool`1.Clear">
            Clears all pooled stacks of this type.
            This is an O(n) operation, where n is the number of pooled stacks
        </member>
        <member name="M:Pathfinding.Util.StackPool`1.GetSize">
            Number of stacks of this type in the pool 
        </member>
        <member name="T:Pathfinding.Util.Checksum">
            Calculates checksums of byte arrays 
        </member>
        <member name="M:Pathfinding.Util.Checksum.GetChecksum(System.Byte[])">
            Calculate checksum for the byte array 
        </member>
        <member name="M:Pathfinding.Util.Checksum.GetChecksum(System.Byte[],System.UInt32)">
            Calculate checksum for the byte array starting from a previous values.
            Useful if data is split up between several byte arrays 
        </member>
        <member name="M:Pathfinding.Util.Memory.MemSet(System.Byte[],System.Byte)">
            Sets all values in an array to a specific value faster than a loop.
             Only faster for large arrays. Slower for small ones.
             Tests indicate it becomes faster somewhere when the length of the array grows above around 100.
             For large arrays this can be magnitudes faster. Up to 40 times faster has been measured.
            
             \see System.Buffer.BlockCopy
        </member>
        <!-- Badly formed XML comment ignored for member "M:Pathfinding.Util.Memory.MemSet``1(``0[],``0,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Pathfinding.Util.Memory.MemSet``1(``0[],``0,System.Int32,System.Int32)" -->
        <member name="T:Pathfinding.Util.Guid">
            Simple implementation of a GUID.
            \version Since 3.6.4 this struct works properly on platforms with different endianness such as Wii U.
        </member>
        <member name="M:Pathfinding.Util.Guid.SwapEndianness(System.UInt64)">
            Swaps between little and big endian 
        </member>
        <member name="T:Pathfinding.Util.LockFreeStack">
            Implements a lock free multiple producer - single consumer stack for the Path object.
             Though it probably works for multiple producer - multiple consumer as well.
            
             On iOS it degrades to using locking since Interlocked.CompareExchange is not available
             on the iOS platform.
            
             \todo Add SINGLE_THREAD_OPTIMIZE define
        </member>
        <member name="M:Pathfinding.Util.LockFreeStack.Push(Pathfinding.Path)">
            Pushes a path onto the stack.
            Will loop while trying to set the head of the stack to \a p. 
        </member>
        <member name="M:Pathfinding.Util.LockFreeStack.PopAll">
            Pops all items from the stack and returns the head.
            To loop through all popped items, simple traverse the linked list starting with the head and continuing with item.next until item equals null
            \code
            Path p = stack.PopAll ();
            while (p != null) {
             //Do something
             p = p.next;
            }
            \endcode
        </member>
        <member name="F:Pathfinding.NodeLink.end">
            End position of the link 
        </member>
        <member name="F:Pathfinding.NodeLink.costFactor">
            The connection will be this times harder/slower to traverse.
            Note that values lower than one will not always make the pathfinder choose this path instead of another path even though this one should
            lead to a lower total cost unless you also adjust the Heuristic Scale in A* Inspector -> Settings -> Pathfinding or disable the heuristic altogether.
        </member>
        <member name="F:Pathfinding.NodeLink.oneWay">
            Make a one-way connection 
        </member>
        <member name="F:Pathfinding.NodeLink.deleteConnection">
            Delete existing connection instead of adding one 
        </member>
        <member name="F:Pathfinding.NodeLink2.end">
            End position of the link 
        </member>
        <member name="F:Pathfinding.NodeLink2.costFactor">
            The connection will be this times harder/slower to traverse.
            Note that values lower than one will not always make the pathfinder choose this path instead of another path even though this one should
            lead to a lower total cost unless you also adjust the Heuristic Scale in A* Inspector -> Settings -> Pathfinding or disable the heuristic altogether.
        </member>
        <member name="F:Pathfinding.NodeLink2.oneWay">
            Make a one-way connection 
        </member>
        <member name="F:Pathfinding.NodeLink3.end">
            End position of the link 
        </member>
        <member name="F:Pathfinding.NodeLink3.costFactor">
            The connection will be this times harder/slower to traverse.
            Note that values lower than one will not always make the pathfinder choose this path instead of another path even though this one should
            lead to a lower total cost unless you also adjust the Heuristic Scale in A* Inspector -> Settings -> Pathfinding or disable the heuristic altogether.
        </member>
        <member name="F:Pathfinding.NodeLink3.oneWay">
            Make a one-way connection 
        </member>
        <member name="T:Pathfinding.PathPool">
            Pools path objects to reduce load on the garbage collector 
        </member>
        <member name="M:Pathfinding.PathPool.Pool(Pathfinding.Path)">
            Adds a path to the pool.
            This function should not be used directly. Instead use the Path.Claim and Path.Release functions.
        </member>
        <member name="M:Pathfinding.PathPool.GetTotalCreated(System.Type)">
            Total created instances of paths of the specified type 
        </member>
        <member name="M:Pathfinding.PathPool.GetSize(System.Type)">
            Number of pooled instances of a path of the specified type 
        </member>
        <member name="M:Pathfinding.PathPool.GetPath``1">
            Get a path from the pool or create a new one if the pool is empty 
        </member>
        <member name="T:Pathfinding.PathPool`1">
            Pools path objects to reduce load on the garbage collector 
        </member>
        <member name="M:Pathfinding.PathPool`1.Recycle(`0)">
            Recycles a path and puts in the pool.
            This function should not be used directly. Instead use the Path.Claim and Path.Release functions.
        </member>
        <member name="M:Pathfinding.PathPool`1.Warmup(System.Int32,System.Int32)">
            Warms up path, node list and vector list pools.
            Makes sure there is at least \a count paths, each with a minimum capacity for paths with length \a length in the pool.
            The capacity means that paths shorter or equal to the capacity can be calculated without any large allocations taking place.
        </member>
        <member name="T:Pathfinding.ThreadControlQueue">
            Queue of paths to be processed by the system 
        </member>
        <member name="F:Pathfinding.ThreadControlQueue.blockedReceivers">
            Number of receiver threads that are currently blocked.
            This is only modified while a thread has a lock on lockObj
        </member>
        <member name="F:Pathfinding.ThreadControlQueue.starving">
            True while head == null.
            This is only modified while a thread has a lock on lockObj
        </member>
        <member name="F:Pathfinding.ThreadControlQueue.terminate">
            True after TerminateReceivers has been called.
            All receivers will be terminated when they next call Pop.
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.#ctor(System.Int32)">
            Create a new queue with the specified number of receivers.
            It is important that the number of receivers is fixed.
            Properties like AllReceiversBlocked rely on knowing the exact number of receivers using the Pop (or PopNoBlock) methods.
        </member>
        <member name="P:Pathfinding.ThreadControlQueue.IsEmpty">
            True if the queue is empty 
        </member>
        <member name="P:Pathfinding.ThreadControlQueue.IsTerminating">
            True if TerminateReceivers has been called 
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.Block">
            Block queue, all calls to Pop will block until Unblock is called 
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.Unblock">
            Unblock queue.
            Calls to Pop will not block anymore.
            \see Block
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.Lock">
            Aquires a lock on this queue.
            Must be paired with a call to #Unlock 
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.Unlock">
            Releases the lock on this queue 
        </member>
        <member name="P:Pathfinding.ThreadControlQueue.AllReceiversBlocked">
            True if blocking and all receivers are waiting for unblocking 
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.PushFront(Pathfinding.Path)">
            Push a path to the front of the queue 
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.Push(Pathfinding.Path)">
            Push a path to the end of the queue 
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.TerminateReceivers">
            All calls to Pop and PopNoBlock will now generate exceptions 
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.Pop">
            Pops the next item off the queue.
             This call will block if there are no items in the queue or if the queue is currently blocked.
            
             \returns A Path object, guaranteed to be not null.
             \throws QueueTerminationException if #TerminateReceivers has been called.
             \throws System.InvalidOperationException if more receivers get blocked than the fixed count sent to the constructor
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.ReceiverTerminated">
            Call when a receiver was terminated in other ways than by a QueueTerminationException.
            
             After this call, the receiver should be dead and not call anything else in this class.
        </member>
        <member name="M:Pathfinding.ThreadControlQueue.PopNoBlock(System.Boolean)">
            Pops the next item off the queue, this call will not block.
             To ensure stability, the caller must follow this pattern.
             1. Call PopNoBlock(false), if a null value is returned, wait for a bit (e.g yield return null in a Unity coroutine)
             2. try again with PopNoBlock(true), if still null, wait for a bit
             3. Repeat from step 2.
            
             \throws QueueTerminationException if #TerminateReceivers has been called.
             \throws System.InvalidOperationException if more receivers get blocked than the fixed count sent to the constructor
        </member>
        <member name="F:Pathfinding.GraphNode.nodeIndex">
            Internal unique index 
        </member>
        <member name="F:Pathfinding.GraphNode.flags">
            Bitpacked field holding several pieces of data.
            \see Walkable
            \see Area
            \see GraphIndex
            \see Tag
        </member>
        <member name="F:Pathfinding.GraphNode.penalty">
            Penalty cost for walking on this node.
             This can be used to make it harder/slower to walk over certain nodes.
            
             A penalty of 1000 (Int3.Precision) corresponds to the cost of walking one world unit.
        </member>
        <member name="M:Pathfinding.GraphNode.#ctor(AstarPath)">
            Constructor for a graph node. 
        </member>
        <member name="M:Pathfinding.GraphNode.Destroy">
            Destroys the node.
             Cleans up any temporary pathfinding data used for this node.
             The graph is responsible for calling this method on nodes when they are destroyed, including when the whole graph is destoyed.
             Otherwise memory leaks might present themselves.
            
             Once called the #Destroyed property will return true and subsequent calls to this method will not do anything.
            
             \note Assumes the current active AstarPath instance is the same one that created this node.
            
             \warning Should only be called by graph classes on their own nodes
        </member>
        <member name="P:Pathfinding.GraphNode.NodeIndex">
            Internal unique index.
            Every node will get a unique index.
            This index is not necessarily correlated with e.g the position of the node in the graph.
        </member>
        <member name="F:Pathfinding.GraphNode.position">
            Position of the node in world space.
            \note The position is stored as an Int3, not a Vector3.
            You can convert an Int3 to a Vector3 using an explicit conversion.
            \code var v3 = (Vector3)node.position; \endcode
        </member>
        <member name="F:Pathfinding.GraphNode.FlagsWalkableOffset">
            Position of the walkable bit. \see Walkable 
        </member>
        <member name="F:Pathfinding.GraphNode.FlagsWalkableMask">
            Mask of the walkable bit. \see Walkable 
        </member>
        <member name="F:Pathfinding.GraphNode.FlagsAreaOffset">
            Start of area bits. \see Area 
        </member>
        <member name="F:Pathfinding.GraphNode.FlagsAreaMask">
            Mask of area bits. \see Area 
        </member>
        <member name="F:Pathfinding.GraphNode.FlagsGraphOffset">
            Start of graph index bits. \see GraphIndex 
        </member>
        <member name="F:Pathfinding.GraphNode.FlagsGraphMask">
            Mask of graph index bits. \see GraphIndex 
        </member>
        <member name="F:Pathfinding.GraphNode.MaxGraphIndex">
            Max number of graphs-1 
        </member>
        <member name="F:Pathfinding.GraphNode.FlagsTagOffset">
            Start of tag bits. \see Tag 
        </member>
        <member name="F:Pathfinding.GraphNode.FlagsTagMask">
            Mask of tag bits. \see Tag 
        </member>
        <member name="P:Pathfinding.GraphNode.Flags">
            Holds various bitpacked variables.
        </member>
        <member name="P:Pathfinding.GraphNode.Penalty">
            Penalty cost for walking on this node. This can be used to make it harder/slower to walk over certain areas. 
        </member>
        <member name="P:Pathfinding.GraphNode.Walkable">
            True if the node is traversable 
        </member>
        <member name="M:Pathfinding.GraphNode.GetConnections(Pathfinding.GraphNodeDelegate)">
            Calls the delegate with all connections from this node 
        </member>
        <member name="M:Pathfinding.GraphNode.ClearConnections(System.Boolean)">
            Remove all connections from this node.
            \param alsoReverse if true, neighbours will be requested to remove connections to this node.
        </member>
        <member name="M:Pathfinding.GraphNode.ContainsConnection(Pathfinding.GraphNode)">
            Checks if this node has a connection to the specified node 
        </member>
        <member name="M:Pathfinding.GraphNode.RecalculateConnectionCosts">
            Recalculates all connection costs from this node.
            Depending on the node type, this may or may not be supported.
            Nothing will be done if the operation is not supported
            \todo Use interface?
        </member>
        <member name="M:Pathfinding.GraphNode.GetPortal(Pathfinding.GraphNode,System.Collections.Generic.List{UnityEngine.Vector3},System.Collections.Generic.List{UnityEngine.Vector3},System.Boolean)">
            Add a portal from this node to the specified node.
             This function should add a portal to the left and right lists which is connecting the two nodes (\a this and \a other).
            
             \param other The node which is on the other side of the portal (strictly speaking it does not actually have to be on the other side of the portal though).
             \param left List of portal points on the left side of the funnel
             \param right List of portal points on the right side of the funnel
             \param backwards If this is true, the call was made on a node with the \a other node as the node before this one in the path.
             In this case you may choose to do nothing since a similar call will be made to the \a other node with this node referenced as \a other (but then with backwards = true).
             You do not have to care about switching the left and right lists, that is done for you already.
            
             \returns True if the call was deemed successful. False if some unknown case was encountered and no portal could be added.
             If both calls to node1.GetPortal (node2,...) and node2.GetPortal (node1,...) return false, the funnel modifier will fall back to adding to the path
             the positions of the node.
            
             The default implementation simply returns false.
            
             This function may add more than one portal if necessary.
            
             \see http://digestingduck.blogspot.se/2010/03/simple-stupid-funnel-algorithm.html
        </member>
        <member name="M:Pathfinding.GraphNode.Open(Pathfinding.Path,Pathfinding.PathNode,Pathfinding.PathHandler)">
            Open the node 
        </member>
        <member name="M:Pathfinding.GraphNode.SerializeReferences(Pathfinding.Serialization.GraphSerializationContext)">
            Used to serialize references to other nodes e.g connections.
             Use the GraphSerializationContext.GetNodeIdentifier and
             GraphSerializationContext.GetNodeFromIdentifier methods
             for serialization and deserialization respectively.
            
             Nodes must override this method and serialize their connections.
             Graph generators do not need to call this method, it will be called automatically on all
             nodes at the correct time by the serializer.
        </member>
        <member name="M:Pathfinding.GraphNode.DeserializeReferences(Pathfinding.Serialization.GraphSerializationContext)">
            Used to deserialize references to other nodes e.g connections.
             Use the GraphSerializationContext.GetNodeIdentifier and
             GraphSerializationContext.GetNodeFromIdentifier methods
             for serialization and deserialization respectively.
            
             Nodes must override this method and serialize their connections.
             Graph generators do not need to call this method, it will be called automatically on all
             nodes at the correct time by the serializer.
        </member>
        <member name="M:Pathfinding.MeshNode.AddConnection(Pathfinding.GraphNode,System.UInt32)">
            Add a connection from this node to the specified node.
             If the connection already exists, the cost will simply be updated and
             no extra connection added.
            
             \note Only adds a one-way connection. Consider calling the same function on the other node
             to get a two-way connection.
        </member>
        <member name="M:Pathfinding.MeshNode.RemoveConnection(Pathfinding.GraphNode)">
            Removes any connection from this node to the specified node.
             If no such connection exists, nothing will be done.
            
             \note This only removes the connection from this node to the other node.
             You may want to call the same function on the other node to remove its eventual connection
             to this node.
        </member>
        <member name="M:Pathfinding.MeshNode.ContainsPoint(Pathfinding.Int3)">
            Checks if \a p is inside the node in XZ space
            
             The default implementation uses XZ space and is in large part got from the website linked below
             \author http://unifycommunity.com/wiki/index.php?title=PolyContainsPoint (Eric5h5)
            
             The TriangleMeshNode overrides this and implements faster code for that case.
        </member>
        <member name="T:Pathfinding.Path">
            Base class for all path types 
        </member>
        <member name="P:Pathfinding.Path.pathHandler">
            Data for the thread calculating this path 
        </member>
        <member name="F:Pathfinding.Path.callback">
            Callback to call when the path is complete.
            This is usually sent to the Seeker component which post processes the path and then calls a callback to the script which requested the path
        </member>
        <member name="F:Pathfinding.Path.immediateCallback">
            Immediate callback to call when the path is complete.
             \warning This may be called from a separate thread. Usually you do not want to use this one.
            
             \see callback
        </member>
        <member name="F:Pathfinding.Path.pathCompleteState">
            Current state of the path.
            \see #CompleteState
        </member>
        <member name="P:Pathfinding.Path.CompleteState">
            Current state of the path 
        </member>
        <member name="P:Pathfinding.Path.error">
            If the path failed, this is true.
            \see #errorLog
        </member>
        <member name="F:Pathfinding.Path._errorLog">
            Additional info on what went wrong.
            \see #error
        </member>
        <member name="P:Pathfinding.Path.errorLog">
            Log messages with info about eventual errors. 
        </member>
        <member name="F:Pathfinding.Path.path">
            Holds the path as a Node array. All nodes the path traverses.
            This might not be the same as all nodes the smoothed path traverses.
        </member>
        <member name="F:Pathfinding.Path.vectorPath">
            Holds the (perhaps post processed) path as a Vector3 list 
        </member>
        <member name="F:Pathfinding.Path.maxFrameTime">
            The max number of milliseconds per iteration (frame, in case of non-multithreading) 
        </member>
        <member name="F:Pathfinding.Path.currentR">
            The node currently being processed 
        </member>
        <member name="F:Pathfinding.Path.duration">
            The duration of this path in ms. How long it took to calculate the path 
        </member>
        <member name="F:Pathfinding.Path.searchIterations">
            The number of frames/iterations this path has executed.
            This is the number of frames when not using multithreading.
            When using multithreading, this value is quite irrelevant
        </member>
        <member name="F:Pathfinding.Path.searchedNodes">
            Number of nodes this path has searched 
        </member>
        <member name="P:Pathfinding.Path.callTime">
            When the call was made to start the pathfinding for this path 
        </member>
        <member name="F:Pathfinding.Path.pooled">
            True if the path is currently pooled.
             Do not set this value. Only read. It is used internally.
            
             \see PathPool
             \version Was named 'recycled' in 3.7.5 and earlier.
        </member>
        <member name="P:Pathfinding.Path.recycled">
            True if the path is currently recycled (i.e in the path pool).
             Do not set this value. Only read. It is used internally.
            
             \deprecated Has been renamed to 'pooled' to use more widely underestood terminology
        </member>
        <member name="F:Pathfinding.Path.hasBeenReset">
            True if the Reset function has been called.
            Used to alert users when they are doing something wrong.
        </member>
        <member name="F:Pathfinding.Path.nnConstraint">
            Constraint for how to search for nodes 
        </member>
        <member name="F:Pathfinding.Path.next">
            Internal linked list implementation.
            \warning This is used internally by the system. You should never change this.
        </member>
        <member name="F:Pathfinding.Path.heuristic">
            Determines which heuristic to use 
        </member>
        <member name="F:Pathfinding.Path.heuristicScale">
            Scale of the heuristic values 
        </member>
        <member name="P:Pathfinding.Path.pathID">
            ID of this path. Used to distinguish between different paths 
        </member>
        <member name="F:Pathfinding.Path.hTargetNode">
            Target to use for H score calculation. Used alongside #hTarget. 
        </member>
        <member name="F:Pathfinding.Path.hTarget">
            Target to use for H score calculations. \see Pathfinding.Node.H 
        </member>
        <!-- Badly formed XML comment ignored for member "F:Pathfinding.Path.enabledTags" -->
        <member name="F:Pathfinding.Path.ZeroTagPenalties">
            List of zeroes to use as default tag penalties 
        </member>
        <member name="F:Pathfinding.Path.internalTagPenalties">
            The tag penalties that are actually used.
            If manualTagPenalties is null, this will be ZeroTagPenalties
            \see tagPenalties
        </member>
        <member name="F:Pathfinding.Path.manualTagPenalties">
            Tag penalties set by other scripts
            \see tagPenalties
        </member>
        <member name="P:Pathfinding.Path.tagPenalties">
            Penalties for each tag.
             Tag 0 which is the default tag, will have added a penalty of tagPenalties[0].
             These should only be positive values since the A* algorithm cannot handle negative penalties.
             \note This array will never be null. If you try to set it to null or with a lenght which is not 32. It will be set to "new int[0]".
            
             \note If you are using a Seeker. The Seeker will set this value to what is set in the inspector field on StartPath.
             So you need to change the Seeker value via script, not set this value if you want to change it via script.
            
             \see Seeker.tagPenalties
        </member>
        <member name="P:Pathfinding.Path.FloodingPath">
            True for paths that want to search all nodes and not jump over nodes as optimizations.
            This disables Jump Point Search when that is enabled to prevent e.g ConstantPath and FloodPath
            to become completely useless.
        </member>
        <member name="M:Pathfinding.Path.GetTotalLength">
            Total Length of the path.
            Calculates the total length of the #vectorPath.
            Cache this rather than call this function every time since it will calculate the length every time, not just return a cached value.
            \returns Total length of #vectorPath, if #vectorPath is null positive infinity is returned.
        </member>
        <member name="M:Pathfinding.Path.WaitForPath">
            Waits until this path has been calculated and returned.
             Allows for very easy scripting.
             \code
             //In an IEnumerator function
            
             Path p = Seeker.StartPath (transform.position, transform.position + Vector3.forward * 10);
             yield return StartCoroutine (p.WaitForPath ());
            
             //The path is calculated at this stage
             \endcode
             \note Do not confuse this with AstarPath.WaitForPath. This one will wait using yield until it has been calculated
             while AstarPath.WaitForPath will halt all operations until the path has been calculated.
            
             \throws System.InvalidOperationException if the path is not started. Send the path to Seeker.StartPath or AstarPath.StartPath before calling this function.
            
             \see AstarPath.WaitForPath
        </member>
        <member name="M:Pathfinding.Path.CalculateHScore(Pathfinding.GraphNode)">
            Estimated cost from the specified node to the target.
            \see https://en.wikipedia.org/wiki/A*_search_algorithm
        </member>
        <member name="M:Pathfinding.Path.GetTagPenalty(System.Int32)">
            Returns penalty for the given tag.
            \param tag A value between 0 (inclusive) and 32 (exclusive).
        </member>
        <member name="M:Pathfinding.Path.CanTraverse(Pathfinding.GraphNode)">
            Returns if the node can be traversed.
            This per default equals to if the node is walkable and if the node's tag is included in #enabledTags 
        </member>
        <member name="M:Pathfinding.Path.GetConnectionSpecialCost(Pathfinding.GraphNode,Pathfinding.GraphNode,System.UInt32)">
            May be called by graph nodes to get a special cost for some connections.
             Nodes may call it when PathNode.flag2 is set to true, for example mesh nodes, which have
             a very large area can be marked on the start and end nodes, this method will be called
             to get the actual cost for moving from the start position to its neighbours instead
             of as would otherwise be the case, from the start node's position to its neighbours.
             The position of a node and the actual start point on the node can vary quite a lot.
            
             The default behaviour of this method is to return the previous cost of the connection,
             essentiall making no change at all.
            
             This method should return the same regardless of the order of a and b.
             That is f(a,b) == f(b,a) should hold.
            
             \param a Moving from this node
             \param b Moving to this node
             \param currentCost The cost of moving between the nodes. Return this value if there is no meaningful special cost to return.
        </member>
        <member name="M:Pathfinding.Path.IsDone">
            Returns if this path is done calculating.
             \returns If CompleteState is not PathCompleteState.NotCalculated.
            
             \note The path might not have been returned yet.
            
             \since Added in 3.0.8
            
             \see Seeker.IsDone
        </member>
        <member name="M:Pathfinding.Path.AdvanceState(PathState)">
            Threadsafe increment of the state 
        </member>
        <member name="M:Pathfinding.Path.GetState">
            Returns the state of the path in the pathfinding pipeline 
        </member>
        <member name="M:Pathfinding.Path.LogError(System.String)">
            Appends \a msg to #errorLog and logs \a msg to the console.
            Debug.Log call is only made if AstarPath.logPathResults is not equal to None and not equal to InGame.
            Consider calling Error() along with this call.
        </member>
        <member name="M:Pathfinding.Path.ForceLogError(System.String)">
            Logs an error and calls Error().
            This is called only if something is very wrong or the user is doing something he/she really should not be doing.
        </member>
        <member name="M:Pathfinding.Path.Log(System.String)">
            Appends a message to the #errorLog.
             Nothing is logged to the console.
            
             \note If AstarPath.logPathResults is PathLog.None and this is a standalone player, nothing will be logged as an optimization.
        </member>
        <member name="M:Pathfinding.Path.Error">
            Aborts the path because of an error.
            Sets #error to true.
            This function is called when an error has ocurred (e.g a valid path could not be found).
            \see LogError
        </member>
        <member name="M:Pathfinding.Path.ErrorCheck">
            Does some error checking.
             Makes sure the user isn't using old code paths and that no major errors have been done.
            
             \throws An exception if any errors are found
        </member>
        <member name="M:Pathfinding.Path.OnEnterPool">
            Called when the path enters the pool.
            This method should release e.g pooled lists and other pooled resources
            The base version of this method releases vectorPath and path lists.
            Reset() will be called after this function, not before.
            \warning Do not call this function manually.
        </member>
        <member name="M:Pathfinding.Path.Reset">
            Reset all values to their default values.
            
             \note All inheriting path types (e.g ConstantPath, RandomPath, etc.) which declare their own variables need to
             override this function, resetting ALL their variables to enable recycling of paths.
             If this is not done, trying to use that path type for pooling might result in weird behaviour.
             The best way is to reset to default values the variables declared in the extended path type and then
             call this base function in inheriting types with base.Reset ().
            
             \warning This function should not be called manually.
        </member>
        <member name="F:Pathfinding.Path.claimed">
            List of claims on this path with reference objects 
        </member>
        <member name="F:Pathfinding.Path.releasedNotSilent">
            True if the path has been released with a non-silent call yet.
            
             \see Release
             \see Claim
        </member>
        <member name="M:Pathfinding.Path.Claim(System.Object)">
            Claim this path (pooling).
             A claim on a path will ensure that it is not pooled.
             If you are using a path, you will want to claim it when you first get it and then release it when you will not
             use it anymore. When there are no claims on the path, it will be reset and put in a pool.
            
             This is essentially just reference counting.
            
             The object passed to this method is merely used as a way to more easily detect when pooling is not done correctly.
             It can be any object, when used from a movement script you can just pass "this". This class will throw an exception
             if you try to call Claim on the same path twice with the same object (which is usually not what you want) or
             if you try to call Release with an object that has not been used in a Claim call for that path.
             The object passed to the Claim method needs to be the same as the one you pass to this method.
            
             \see Release
             \see Pool
             \see \ref pooling
        </member>
        <member name="M:Pathfinding.Path.ReleaseSilent(System.Object)">
            Releases the path silently (pooling).
            \deprecated Use Release(o, true) instead
        </member>
        <member name="M:Pathfinding.Path.Release(System.Object,System.Boolean)">
            Releases a path claim (pooling).
             Removes the claim of the path by the specified object.
             When the claim count reaches zero, the path will be pooled, all variables will be cleared and the path will be put in a pool to be used again.
             This is great for memory since less allocations are made.
            
             If the silent parameter is true, this method will remove the claim by the specified object
             but the path will not be pooled if the claim count reches zero unless a Release call (not silent) has been made earlier.
             This is used by the internal pathfinding components such as Seeker and AstarPath so that they will not cause paths to be pooled.
             This enables users to skip the claim/release calls if they want without the path being pooled by the Seeker or AstarPath and
             thus causing strange bugs.
            
             \see Claim
             \see PathPool
        </member>
        <member name="M:Pathfinding.Path.Trace(Pathfinding.PathNode)">
            Traces the calculated path from the end node to the start.
            This will build an array (#path) of the nodes this path will pass through and also set the #vectorPath array to the #path arrays positions.
            Assumes the #vectorPath and #path are empty and not null (which will be the case for a correctly initialized path).
        </member>
        <member name="M:Pathfinding.Path.DebugStringPrefix(PathLog,System.Text.StringBuilder)">
            Writes text shared for all overrides of DebugString to the string builder.
            \see DebugString
        </member>
        <member name="M:Pathfinding.Path.DebugStringSuffix(PathLog,System.Text.StringBuilder)">
            Writes text shared for all overrides of DebugString to the string builder.
            \see DebugString
        </member>
        <member name="M:Pathfinding.Path.DebugString(PathLog)">
            Returns a string with information about it.
            More information is emitted when logMode == Heavy.
            An empty string is returned if logMode == None
            or logMode == OnlyErrors and this path did not fail.
        </member>
        <member name="M:Pathfinding.Path.ReturnPath">
            Calls callback to return the calculated path. \see #callback 
        </member>
        <member name="M:Pathfinding.Path.PrepareBase(Pathfinding.PathHandler)">
            Prepares low level path variables for calculation.
            Called before a path search will take place.
            Always called before the Prepare, Initialize and CalculateStep functions
        </member>
        <member name="M:Pathfinding.Path.Prepare">
            Called before the path is started.
            Called right before Initialize
        </member>
        <member name="M:Pathfinding.Path.Cleanup">
            Always called after the path has been calculated.
            Guaranteed to be called before other paths have been calculated on
            the same thread.
            Use for cleaning up things like node tagging and similar.
        </member>
        <member name="M:Pathfinding.Path.Initialize">
            Initializes the path.
            Sets up the open list and adds the first node to it
        </member>
        <member name="M:Pathfinding.Path.CalculateStep(System.Int64)">
            Calculates the until it is complete or the time has progressed past \a targetTick 
        </member>
        <member name="T:Pathfinding.PathNode">
            Stores temporary node data for a single pathfinding request.
             Every node has one PathNode per thread used.
             It stores e.g G score, H score and other temporary variables needed
             for path calculation, but which are not part of the graph structure.
            
             \see Pathfinding.PathHandler
             \see https://en.wikipedia.org/wiki/A*_search_algorithm
        </member>
        <member name="F:Pathfinding.PathNode.node">
            Reference to the actual graph node 
        </member>
        <member name="F:Pathfinding.PathNode.parent">
            Parent node in the search tree 
        </member>
        <member name="F:Pathfinding.PathNode.pathID">
            The path request (in this thread, if multithreading is used) which last used this node 
        </member>
        <member name="F:Pathfinding.PathNode.flags">
            Bitpacked variable which stores several fields 
        </member>
        <member name="F:Pathfinding.PathNode.CostMask">
            Cost uses the first 28 bits 
        </member>
        <member name="F:Pathfinding.PathNode.Flag1Offset">
            Flag 1 is at bit 28 
        </member>
        <member name="F:Pathfinding.PathNode.Flag2Offset">
            Flag 2 is at bit 29 
        </member>
        <member name="P:Pathfinding.PathNode.flag1">
            Use as temporary flag during pathfinding.
            Pathfinders (only) can use this during pathfinding to mark
            nodes. When done, this flag should be reverted to its default state (false) to
            avoid messing up other pathfinding requests.
        </member>
        <member name="P:Pathfinding.PathNode.flag2">
            Use as temporary flag during pathfinding.
            Pathfinders (only) can use this during pathfinding to mark
            nodes. When done, this flag should be reverted to its default state (false) to
            avoid messing up other pathfinding requests.
        </member>
        <member name="F:Pathfinding.PathNode.g">
            Backing field for the G score 
        </member>
        <member name="F:Pathfinding.PathNode.h">
            Backing field for the H score 
        </member>
        <member name="P:Pathfinding.PathNode.G">
            G score, cost to get to this node 
        </member>
        <member name="P:Pathfinding.PathNode.H">
            H score, estimated cost to get to to the target 
        </member>
        <member name="P:Pathfinding.PathNode.F">
            F score. H score + G score 
        </member>
        <member name="T:Pathfinding.PathHandler">
            Handles thread specific path data.
        </member>
        <member name="F:Pathfinding.PathHandler.pathID">
            Current PathID.
            \see #PathID
        </member>
        <member name="F:Pathfinding.PathHandler.heap">
            Binary heap to keep track of nodes on the "Open list".
            \see https://en.wikipedia.org/wiki/A*_search_algorithm
        </member>
        <member name="P:Pathfinding.PathHandler.PathID">
            ID for the path currently being calculated or last path that was calculated 
        </member>
        <member name="M:Pathfinding.PathHandler.PushNode(Pathfinding.PathNode)">
            Push a node to the heap 
        </member>
        <member name="M:Pathfinding.PathHandler.PopNode">
            Pop the node with the lowest F score from the heap 
        </member>
        <member name="M:Pathfinding.PathHandler.GetHeap">
            The internal heap.
             \note Most things can be accomplished with other methods on this class instead.
            
             \see PushNode
             \see PopNode
             \see HeapEmpty
        </member>
        <member name="M:Pathfinding.PathHandler.RebuildHeap">
            Rebuild the heap to account for changed node values.
            Some path types change the target for the H score in the middle of the path calculation,
            that requires rebuilding the heap to keep it correctly sorted.
        </member>
        <member name="M:Pathfinding.PathHandler.HeapEmpty">
            True if the heap is empty 
        </member>
        <member name="F:Pathfinding.PathHandler.BucketSizeLog2">
            Log2 size of buckets.
            So 10 yields a real bucket size of 1024.
            Be careful with large values.
        </member>
        <member name="F:Pathfinding.PathHandler.BucketSize">
            Real bucket size 
        </member>
        <member name="F:Pathfinding.PathHandler.nodes">
            Array of buckets containing PathNodes 
        </member>
        <member name="F:Pathfinding.PathHandler.DebugStringBuilder">
            StringBuilder that paths can use to build debug strings.
            Better for performance and memory usage to use a single StringBuilder instead of each path creating its own
        </member>
        <member name="M:Pathfinding.PathHandler.DestroyNode(Pathfinding.GraphNode)">
            Internal method to clean up node data 
        </member>
        <member name="M:Pathfinding.PathHandler.InitializeNode(Pathfinding.GraphNode)">
            Internal method to initialize node data 
        </member>
        <member name="M:Pathfinding.PathHandler.GetPathNode(Pathfinding.GraphNode)">
            Returns the PathNode corresponding to the specified node.
            The PathNode is specific to this PathHandler since multiple PathHandlers
            are used at the same time if multithreading is enabled.
        </member>
        <member name="M:Pathfinding.PathHandler.ClearPathIDs">
            Set all nodes' pathIDs to 0.
            \see Pathfinding.PathNode.pathID
        </member>
        <member name="F:Pathfinding.Serialization.MatrixConverter.values">
            Just a temporary array of 16 floats.
            Stores the elements of the matrices temporarily just to avoid
            allocating memory for it each time.
        </member>
        <member name="T:Pathfinding.Serialization.IntKeyDictionaryConverter">
            Enables json serialization of dictionaries with integer keys.
        </member>
        <member name="T:Pathfinding.Serialization.GraphSerializationContext">
            Holds information passed to custom graph serializers 
        </member>
        <member name="F:Pathfinding.Serialization.GraphSerializationContext.reader">
            Deserialization stream.
            Will only be set when deserializing
        </member>
        <member name="F:Pathfinding.Serialization.GraphSerializationContext.writer">
            Serialization stream.
            Will only be set when serializing
        </member>
        <member name="F:Pathfinding.Serialization.GraphSerializationContext.graphIndex">
            Index of the graph which is currently being processed.
            \version uint instead of int after 3.7.5
        </member>
        <member name="T:Pathfinding.Serialization.AstarSerializer">
            Handles low level serialization and deserialization of graph settings and data.
             Mostly for internal use. You can use the methods in the AstarData class for
             higher level serialization and deserialization.
            
             \see AstarData
        </member>
        <member name="F:Pathfinding.Serialization.AstarSerializer.zip">
            Zip which the data is loaded from 
        </member>
        <member name="F:Pathfinding.Serialization.AstarSerializer.zipStream">
            Memory stream with the zip data 
        </member>
        <member name="F:Pathfinding.Serialization.AstarSerializer.meta">
            Graph metadata 
        </member>
        <member name="F:Pathfinding.Serialization.AstarSerializer.settings">
            Settings for serialization 
        </member>
        <member name="F:Pathfinding.Serialization.AstarSerializer.graphs">
            Graphs that are being serialized or deserialized 
        </member>
        <member name="F:Pathfinding.Serialization.AstarSerializer.graphIndexInZip">
            Index used for the graph in the file.
            If some graphs were null in the file then graphIndexInZip[graphs[i]] may not equal i.
            Used for deserialization.
        </member>
        <member name="F:Pathfinding.Serialization.AstarSerializer.binaryExt">
            Extension to use for binary files 
        </member>
        <member name="F:Pathfinding.Serialization.AstarSerializer.jsonExt">
            Extension to use for json files 
        </member>
        <member name="F:Pathfinding.Serialization.AstarSerializer.checksum">
            Checksum for the serialized data.
            Used to provide a quick equality check in editor code
        </member>
        <member name="F:Pathfinding.Serialization.AstarSerializer._stringBuilder">
            Cached StringBuilder to avoid excessive allocations 
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.GetStringBuilder">
            Returns a cached StringBuilder.
            This function only has one string builder cached and should
            thus only be called from a single thread and should not be called while using an earlier got string builder.
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.SerializeMeta">
            Serialize metadata about all graphs 
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.Serialize(Pathfinding.NavGraph)">
            Serializes the graph settings to JSON and returns the data 
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.SerializeNodes">
            Deprecated method to serialize node data.
            \deprecated Not used anymore
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.SerializeGraphExtraInfo(Pathfinding.NavGraph)">
            Serializes info returned by NavGraph.SerializeExtraInfo 
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.SerializeGraphNodeReferences(Pathfinding.NavGraph)">
            Used to serialize references to other nodes e.g connections.
            Nodes use the GraphSerializationContext.GetNodeIdentifier and
            GraphSerializationContext.GetNodeFromIdentifier methods
            for serialization and deserialization respectively.
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.FullyDefinedVersion(System.Version)">
            Returns a version with all fields fully defined.
            This is used because by default new Version(3,0,0) > new Version(3,0).
            This is not the desired behaviour so we make sure that all fields are defined here
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.DeserializeGraphs">
            Deserializes graph settings.
            \note Stored in files named "graph#.json" where # is the graph number.
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.DeserializeExtraInfo">
            Deserializes extra graph info.
            Extra graph info is specified by the graph types.
            \see Pathfinding.NavGraph.DeserializeExtraInfo
            \note Stored in files named "graph#_extra.binary" where # is the graph number.
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.PostDeserialization">
            Calls PostDeserialization on all loaded graphs 
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.DeserializeEditorSettings(Pathfinding.GraphEditorBase[])">
            Deserializes graph editor settings.
            For future compatibility this method does not assume that the \a graphEditors array matches the #graphs array in order and/or count.
            It searches for a matching graph (matching if graphEditor.target == graph) for every graph editor.
            Multiple graph editors should not refer to the same graph.\n
            \note Stored in files named "graph#_editor.json" where # is the graph number.
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.GetBinaryReader(Pathfinding.Ionic.Zip.ZipEntry)">
            Returns a binary reader for the data in the zip entry 
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.GetString(Pathfinding.Ionic.Zip.ZipEntry)">
            Returns the data in the zip entry as a string 
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.SaveToFile(System.String,System.Byte[])">
            Save the specified data at the specified path 
        </member>
        <member name="M:Pathfinding.Serialization.AstarSerializer.LoadFromFile(System.String)">
            Load the specified data from the specified path 
        </member>
        <member name="T:Pathfinding.Serialization.GraphMeta">
            Metadata for all graphs included in serialization 
        </member>
        <member name="F:Pathfinding.Serialization.GraphMeta.version">
            Project version it was saved with 
        </member>
        <member name="F:Pathfinding.Serialization.GraphMeta.graphs">
            Number of graphs serialized 
        </member>
        <member name="F:Pathfinding.Serialization.GraphMeta.guids">
            Guids for all graphs 
        </member>
        <member name="F:Pathfinding.Serialization.GraphMeta.typeNames">
            Type names for all graphs 
        </member>
        <member name="F:Pathfinding.Serialization.GraphMeta.nodeCounts">
            Number of nodes for every graph. Nodes are not necessarily serialized 
        </member>
        <member name="M:Pathfinding.Serialization.GraphMeta.GetGraphType(System.Int32)">
            Returns the Type of graph number \a i 
        </member>
        <member name="T:Pathfinding.Serialization.SerializeSettings">
            Holds settings for how graphs should be serialized 
        </member>
        <member name="F:Pathfinding.Serialization.SerializeSettings.nodes">
            Enable to include node data.
            If false, only settings will be saved
        </member>
        <member name="F:Pathfinding.Serialization.SerializeSettings.prettyPrint">
            Use pretty printing for the json data.
            Good if you want to open up the saved data and edit it manually
        </member>
        <member name="F:Pathfinding.Serialization.SerializeSettings.editorSettings">
            Save editor settings.
            \warning Only applicable when saving from the editor using the AstarPathEditor methods
        </member>
        <member name="P:Pathfinding.Serialization.SerializeSettings.Settings">
            Serialization settings for only saving graph settings 
        </member>
        <member name="P:Pathfinding.Serialization.SerializeSettings.All">
            Serialization settings for saving everything that can be saved.
            This includes all node data
        </member>
        <member name="F:Pathfinding.AstarColor._AreaColors">
            Holds user set area colors.
            Use GetAreaColor to get an area color 
        </member>
        <member name="F:Pathfinding.AstarColor.AreaColors">
            Holds user set area colors.
            Use GetAreaColor to get an area color 
        </member>
        <member name="M:Pathfinding.AstarColor.GetAreaColor(System.UInt32)">
            Returns an color for an area, uses both user set ones and calculated.
            If the user has set a color for the area, it is used, but otherwise the color is calculated using Mathfx.IntToColor
            \see #AreaColors 
        </member>
        <member name="M:Pathfinding.AstarColor.OnEnable">
            Pushes all local variables out to static ones 
        </member>
        <member name="T:Pathfinding.GraphHitInfo">
            Returned by graph ray- or linecasts containing info about the hit. This will only be set up if something was hit. 
        </member>
        <member name="F:Pathfinding.GraphHitInfo.origin">
            Start of the line/ray 
        </member>
        <member name="F:Pathfinding.GraphHitInfo.point">
            Hit point 
        </member>
        <member name="F:Pathfinding.GraphHitInfo.node">
            Node which contained the edge which was hit 
        </member>
        <member name="F:Pathfinding.GraphHitInfo.tangentOrigin">
            Where the tangent starts. tangentOrigin and tangent together actually describes the edge which was hit 
        </member>
        <member name="F:Pathfinding.GraphHitInfo.tangent">
            Tangent of the edge which was hit 
        </member>
        <member name="T:Pathfinding.NNConstraint">
            Nearest node constraint. Constrains which nodes will be returned by the GetNearest function 
        </member>
        <!-- Badly formed XML comment ignored for member "F:Pathfinding.NNConstraint.graphMask" -->
        <member name="F:Pathfinding.NNConstraint.constrainArea">
            Only treat nodes in the area #area as suitable. Does not affect anything if #area is less than 0 (zero) 
        </member>
        <member name="F:Pathfinding.NNConstraint.area">
            Area ID to constrain to. Will not affect anything if less than 0 (zero) or if #constrainArea is false 
        </member>
        <member name="F:Pathfinding.NNConstraint.constrainWalkability">
            Only treat nodes with the walkable flag set to the same as #walkable as suitable 
        </member>
        <member name="F:Pathfinding.NNConstraint.walkable">
            What must the walkable flag on a node be for it to be suitable. Does not affect anything if #constrainWalkability if false 
        </member>
        <member name="F:Pathfinding.NNConstraint.distanceXZ">
            if available, do an XZ check instead of checking on all axes. The RecastGraph supports this 
        </member>
        <member name="F:Pathfinding.NNConstraint.constrainTags">
            Sets if tags should be constrained 
        </member>
        <member name="F:Pathfinding.NNConstraint.tags">
            Nodes which have any of these tags set are suitable. This is a bitmask, i.e bit 0 indicates that tag 0 is good, bit 3 indicates tag 3 is good etc. 
        </member>
        <member name="F:Pathfinding.NNConstraint.constrainDistance">
            Constrain distance to node.
            Uses distance from AstarPath.maxNearestNodeDistance.
            If this is false, it will completely ignore the distance limit.
            \note This value is not used in this class, it is used by the AstarPath.GetNearest function.
        </member>
        <member name="M:Pathfinding.NNConstraint.SuitableGraph(System.Int32,Pathfinding.NavGraph)">
            Returns whether or not the graph conforms to this NNConstraint's rules.
            Note that only the first 31 graphs are considered using this function.
            If the graphMask has bit 31 set (i.e the last graph possible to fit in the mask), all graphs
            above index 31 will also be considered suitable.
        </member>
        <member name="M:Pathfinding.NNConstraint.Suitable(Pathfinding.GraphNode)">
            Returns whether or not the node conforms to this NNConstraint's rules 
        </member>
        <member name="P:Pathfinding.NNConstraint.Default">
            The default NNConstraint.
            Equivalent to new NNConstraint ().
            This NNConstraint has settings which works for most, it only finds walkable nodes
            and it constrains distance set by A* Inspector -> Settings -> Max Nearest Node Distance 
        </member>
        <member name="P:Pathfinding.NNConstraint.None">
            Returns a constraint which will not filter the results 
        </member>
        <member name="M:Pathfinding.NNConstraint.#ctor">
            Default constructor. Equals to the property #Default 
        </member>
        <member name="T:Pathfinding.PathNNConstraint">
            A special NNConstraint which can use different logic for the start node and end node in a path.
            A PathNNConstraint can be assigned to the Path.nnConstraint field, the path will first search for the start node, then it will call #SetStart and proceed with searching for the end node (nodes in the case of a MultiTargetPath).\n
            The default PathNNConstraint will constrain the end point to lie inside the same area as the start point.
        </member>
        <member name="M:Pathfinding.PathNNConstraint.SetStart(Pathfinding.GraphNode)">
            Called after the start node has been found. This is used to get different search logic for the start and end nodes in a path 
        </member>
        <member name="F:Pathfinding.NNInfo.node">
            Closest node found.
            This node is not necessarily accepted by any NNConstraint passed.
            \see constrainedNode
        </member>
        <member name="F:Pathfinding.NNInfo.constrainedNode">
            Optional to be filled in.
            If the search will be able to find the constrained node without any extra effort it can fill it in. 
        </member>
        <member name="F:Pathfinding.NNInfo.clampedPosition">
            The position clamped to the closest point on the #node.
        </member>
        <member name="F:Pathfinding.NNInfo.constClampedPosition">
            Clamped position for the optional constrainedNode 
        </member>
        <member name="M:Pathfinding.NNInfo.SetConstrained(Pathfinding.GraphNode,UnityEngine.Vector3)">
            Sets the constrained node 
        </member>
        <member name="M:Pathfinding.NNInfo.UpdateInfo">
            Updates #clampedPosition and #constClampedPosition from node positions 
        </member>
        <member name="T:Pathfinding.Progress">
            Progress info for e.g a progressbar.
            Used by the scan functions in the project
            \see AstarPath.ScanLoop
        </member>
        <member name="T:Pathfinding.IUpdatableGraph">
            Graphs which can be updated during runtime 
        </member>
        <member name="M:Pathfinding.IUpdatableGraph.UpdateArea(Pathfinding.GraphUpdateObject)">
            Updates an area using the specified GraphUpdateObject.
            
             Notes to implementators.
             This function should (in order):
             -# Call o.WillUpdateNode on the GUO for every node it will update, it is important that this is called BEFORE any changes are made to the nodes.
             -# Update walkabilty using special settings such as the usePhysics flag used with the GridGraph.
             -# Call Apply on the GUO for every node which should be updated with the GUO.
             -# Update eventual connectivity info if appropriate (GridGraphs updates connectivity, but most other graphs don't since then the connectivity cannot be recovered later).
        </member>
        <member name="T:Pathfinding.GraphUpdateObject">
            Represents a collection of settings used to update nodes in a specific region of a graph.
            \see AstarPath.UpdateGraphs
            \see \ref graph-updates
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.bounds">
            The bounds to update nodes within.
            Defined in world space.
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.requiresFloodFill">
            Controlls if a flood fill will be carried out after this GUO has been applied.
             Disabling this can be used to gain a performance boost, but use with care.
             If you are sure that a GUO will not modify walkability or connections. You can set this to false.
             For example when only updating penalty values it can save processing power when setting this to false. Especially on large graphs.
             \note If you set this to false, even though it does change e.g walkability, it can lead to paths returning that they failed even though there is a path,
             or the try to search the whole graph for a path even though there is none, and will in the processes use wast amounts of processing power.
            
             If using the basic GraphUpdateObject (not a derived class), a quick way to check if it is going to need a flood fill is to check if #modifyWalkability is true or #updatePhysics is true.
            
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.updatePhysics">
            Use physics checks to update nodes.
             When updating a grid graph and this is true, the nodes' position and walkability will be updated using physics checks
             with settings from "Collision Testing" and "Height Testing".
            
             When updating a PointGraph, setting this to true will make it re-evaluate all connections in the graph which passes through the #bounds.
             This has no effect when updating GridGraphs if #modifyWalkability is turned on.
            
             On RecastGraphs, having this enabled will trigger a complete recalculation of all tiles intersecting the bounds.
             This is quite slow (but powerful). If you only want to update e.g penalty on existing nodes, leave it disabled.
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.resetPenaltyOnPhysics">
            When #updatePhysics is true, GridGraphs will normally reset penalties, with this option you can override it.
             Good to use when you want to keep old penalties even when you update the graph.
            
             The images below shows two overlapping graph update objects, the right one happened to be applied before the left one. They both have updatePhysics = true and are
             set to increase the penalty of the nodes by some amount.
            
             The first image shows the result when resetPenaltyOnPhysics is false. Both penalties are added correctly.
             \shadowimage{resetPenaltyOnPhysics_False.png}
            
             This second image shows when resetPenaltyOnPhysics is set to true. The first GUO is applied correctly, but then the second one (the left one) is applied
             and during its updating, it resets the penalties first and then adds penalty to the nodes. The result is that the penalties from both GUOs are not added together.
             The green patch in at the border is there because physics recalculation (recalculation of the position of the node, checking for obstacles etc.) affects a slightly larger
             area than the original GUO bounds because of the Grid Graph -> Collision Testing -> Diameter setting (it is enlarged by that value). So some extra nodes have their penalties reset.
            
             \shadowimage{resetPenaltyOnPhysics_True.png}
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.updateErosion">
            Update Erosion for GridGraphs.
             When enabled, erosion will be recalculated for grid graphs
             after the GUO has been applied.
            
             In the below image you can see the different effects you can get with the different values.\n
             The first image shows the graph when no GUO has been applied. The blue box is not identified as an obstacle by the graph, the reason
             there are unwalkable nodes around it is because there is a height difference (nodes are placed on top of the box) so erosion will be applied (an erosion value of 2 is used in this graph).
             The orange box is identified as an obstacle, so the area of unwalkable nodes around it is a bit larger since both erosion and collision has made
             nodes unwalkable.\n
             The GUO used simply sets walkability to true, i.e making all nodes walkable.
            
             \shadowimage{updateErosion.png}
            
             When updateErosion=True, the reason the blue box still has unwalkable nodes around it is because there is still a height difference
             so erosion will still be applied. The orange box on the other hand has no height difference and all nodes are set to walkable.\n
             \n
             When updateErosion=False, all nodes walkability are simply set to be walkable in this example.
            
             \see Pathfinding.GridGraph
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.nnConstraint">
            NNConstraint to use.
             The Pathfinding.NNConstraint.SuitableGraph function will be called on the NNConstraint to enable filtering of which graphs to update.\n
             \note As the Pathfinding.NNConstraint.SuitableGraph function is A* Pathfinding Project Pro only, this variable doesn't really affect anything in the free version.
            
            
             \astarpro 
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.addPenalty">
            Penalty to add to the nodes.
            A penalty of 1000 is equivalent to the cost of moving 1 world unit.
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.modifyWalkability">
            If true, all nodes' \a walkable variable will be set to #setWalkability 
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.setWalkability">
            If #modifyWalkability is true, the nodes' \a walkable variable will be set to this value 
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.modifyTag">
            If true, all nodes' \a tag will be set to #setTag 
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.setTag">
            If #modifyTag is true, all nodes' \a tag will be set to this value 
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.trackChangedNodes">
            Track which nodes are changed and save backup data.
            Used internally to revert changes if needed.
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.changedNodes">
            Nodes which were updated by this GraphUpdateObject.
            Will only be filled if #trackChangedNodes is true.
            \note It might take a few frames for graph update objects to be applied.
            If you need this info directly, use AstarPath.FlushGraphUpdates.
        </member>
        <member name="F:Pathfinding.GraphUpdateObject.shape">
            A shape can be specified if a bounds object does not give enough precision 
        </member>
        <member name="M:Pathfinding.GraphUpdateObject.WillUpdateNode(Pathfinding.GraphNode)">
            Should be called on every node which is updated with this GUO before it is updated.
            \param node The node to save fields for. If null, nothing will be done
            \see #trackChangedNodes
        </member>
        <member name="M:Pathfinding.GraphUpdateObject.RevertFromBackup">
            Reverts penalties and flags (which includes walkability) on every node which was updated using this GUO.
            Data for reversion is only saved if #trackChangedNodes is true 
        </member>
        <member name="M:Pathfinding.GraphUpdateObject.Apply(Pathfinding.GraphNode)">
            Updates the specified node using this GUO's settings 
        </member>
        <member name="M:Pathfinding.GraphUpdateObject.#ctor(UnityEngine.Bounds)">
            Creates a new GUO with the specified bounds 
        </member>
        <member name="T:Pathfinding.PathThreadInfo">
            Holds info about one pathfinding thread.
            Mainly used to send information about how the thread should execute when starting it
        </member>
        <member name="T:Pathfinding.IntRect">
            Integer Rectangle.
            Works almost like UnityEngine.Rect but with integer coordinates
        </member>
        <member name="M:Pathfinding.IntRect.IsValid">
            Returns if this rectangle is valid.
            An invalid rect could have e.g xmin > xmax.
            Rectamgles with a zero area area invalid.
        </member>
        <member name="M:Pathfinding.IntRect.Intersection(Pathfinding.IntRect,Pathfinding.IntRect)">
            Returns the intersection rect between the two rects.
            The intersection rect is the area which is inside both rects.
            If the rects do not have an intersection, an invalid rect is returned.
            \see IsValid
        </member>
        <member name="M:Pathfinding.IntRect.Intersects(Pathfinding.IntRect,Pathfinding.IntRect)">
            Returns if the two rectangles intersect each other
        </member>
        <member name="M:Pathfinding.IntRect.Union(Pathfinding.IntRect,Pathfinding.IntRect)">
            Returns a new rect which contains both input rects.
            This rectangle may contain areas outside both input rects as well in some cases.
        </member>
        <member name="M:Pathfinding.IntRect.ExpandToContain(System.Int32,System.Int32)">
            Returns a new IntRect which is expanded to contain the point 
        </member>
        <member name="M:Pathfinding.IntRect.Expand(System.Int32)">
            Returns a new rect which is expanded by \a range in all directions.
            \param range How far to expand. Negative values are permitted.
        </member>
        <member name="F:Pathfinding.IntRect.Rotations">
            Matrices for rotation.
            Each group of 4 elements is a 2x2 matrix.
            The XZ position is multiplied by this.
            So
            \code
            //A rotation by 90 degrees clockwise, second matrix in the array
            (5,2) * ((0, 1), (-1, 0)) = (2,-5)
            \endcode
        </member>
        <member name="M:Pathfinding.IntRect.Rotate(System.Int32)">
            Returns a new rect rotated around the origin 90*r degrees.
            Ensures that a valid rect is returned.
        </member>
        <member name="M:Pathfinding.IntRect.Offset(Pathfinding.Int2)">
            Returns a new rect which is offset by the specified amount.
        </member>
        <member name="M:Pathfinding.IntRect.Offset(System.Int32,System.Int32)">
            Returns a new rect which is offset by the specified amount.
        </member>
        <member name="M:Pathfinding.IntRect.DebugDraw(UnityEngine.Matrix4x4,UnityEngine.Color)">
            Draws some debug lines representing the rect 
        </member>
        <member name="T:Pathfinding.MineBotAI">
            AI controller specifically made for the spider robot.
             The spider robot (or mine-bot) which is got from the Unity Example Project
             can have this script attached to be able to pathfind around with animations working properly.\n
             This script should be attached to a parent GameObject however since the original bot has Z+ as up.
             This component requires Z+ to be forward and Y+ to be up.\n
            
             It overrides the AIPath class, see that class's documentation for more information on most variables.\n
             Animation is handled by this component. The Animation component refered to in #anim should have animations named "awake" and "forward".
             The forward animation will have it's speed modified by the velocity and scaled by #animationSpeed to adjust it to look good.
             The awake animation will only be sampled at the end frame and will not play.\n
             When the end of path is reached, if the #endOfPathEffect is not null, it will be instantiated at the current position. However a check will be
             done so that it won't spawn effects too close to the previous spawn-point.
             \shadowimage{mine-bot.png}
            
             \note This script assumes Y is up and that character movement is mostly on the XZ plane.
        </member>
        <member name="F:Pathfinding.MineBotAI.anim">
            Animation component.
            Should hold animations "awake" and "forward"
        </member>
        <member name="F:Pathfinding.MineBotAI.sleepVelocity">
            Minimum velocity for moving 
        </member>
        <member name="F:Pathfinding.MineBotAI.animationSpeed">
            Speed relative to velocity with which to play animations 
        </member>
        <member name="F:Pathfinding.MineBotAI.endOfPathEffect">
            Effect which will be instantiated when end of path is reached.
            \see OnTargetReached 
        </member>
        <member name="F:Pathfinding.MineBotAI.lastTarget">
            Point for the last spawn of #endOfPathEffect 
        </member>
        <member name="M:Pathfinding.MineBotAI.OnTargetReached">
            Called when the end of path has been reached.
            An effect (#endOfPathEffect) is spawned when this function is called
            However, since paths are recalculated quite often, we only spawn the effect
            when the current position is some distance away from the previous spawn-point
        </member>
        <member name="T:Pathfinding.TargetMover">
            Moves the target in example scenes.
             This is a simple script which has the sole purpose
             of moving the target point of agents in the example
             scenes for the A* Pathfinding Project.
            
             It is not meant to be pretty, but it does the job.
        </member>
        <member name="F:Pathfinding.TargetMover.mask">
            Mask for the raycast placement 
        </member>
        <member name="F:Pathfinding.TargetMover.onlyOnDoubleClick">
            Determines if the target position should be updated every frame or only on double-click 
        </member>
        <member name="T:Pathfinding.NavGraph">
             Base class for all graphs 
        </member>
        <member name="F:Pathfinding.NavGraph._sguid">
            Used to store the guid value
            \see NavGraph.guid
        </member>
        <member name="F:Pathfinding.NavGraph.active">
            Reference to the AstarPath object in the scene.
            Might not be entirely safe to use, it's better to use AstarPath.active
        </member>
        <member name="P:Pathfinding.NavGraph.guid">
            Used as an ID of the graph, considered to be unique.
            \note This is Pathfinding.Util.Guid not System.Guid. A replacement for System.Guid was coded for better compatibility with iOS
        </member>
        <member name="F:Pathfinding.NavGraph.initialPenalty">
            Default penalty to apply to all nodes 
        </member>
        <member name="F:Pathfinding.NavGraph.open">
             Is the graph open in the editor 
        </member>
        <member name="F:Pathfinding.NavGraph.graphIndex">
            Index of the graph, used for identification purposes 
        </member>
        <member name="F:Pathfinding.NavGraph.name">
            Name of the graph.
            Can be set in the unity editor
        </member>
        <member name="F:Pathfinding.NavGraph.infoScreenOpen">
            Used in the editor to check if the info screen is open.
            Should be inside UNITY_EDITOR only \#ifs but just in case anyone tries to serialize a NavGraph instance using Unity, I have left it like this as it would otherwise cause a crash when building.
            Version 3.0.8.1 was released because of this bug only
        </member>
        <member name="M:Pathfinding.NavGraph.CountNodes">
            Count nodes in the graph.
             Note that this is, unless the graph type has overriden it, an O(n) operation.
            
             \todo GridGraph should override this
        </member>
        <member name="M:Pathfinding.NavGraph.GetNodes(Pathfinding.GraphNodeDelegateCancelable)">
            Calls a delegate with all nodes in the graph.
             This is the primary way of "looping" through all nodes in a graph.
            
             This function should not change anything in the graph structure.
            
             \code
             myGraph.GetNodes ((node) => {
                 Debug.Log ("I found a node at position " + (Vector3)node.Position);
                 return true;
             });
             \endcode
        </member>
        <member name="F:Pathfinding.NavGraph.matrix">
            A matrix for translating/rotating/scaling the graph.
             Not all graph generators sets this variable though.
            
             \note Do not set directly, use SetMatrix
            
             \note This value is not serialized. It is expected that graphs regenerate this
             field after deserialization has completed.
        </member>
        <member name="F:Pathfinding.NavGraph.inverseMatrix">
            Inverse of \a matrix.
            
             \note Do not set directly, use SetMatrix
            
             \see matrix
        </member>
        <member name="M:Pathfinding.NavGraph.SetMatrix(UnityEngine.Matrix4x4)">
            Use to set both matrix and inverseMatrix at the same time 
        </member>
        <member name="M:Pathfinding.NavGraph.RelocateNodes(UnityEngine.Matrix4x4,UnityEngine.Matrix4x4)">
            Relocates the nodes in this graph.
             Assumes the nodes are already transformed using the "oldMatrix", then transforms them
             such that it will look like they have only been transformed using the "newMatrix".
             The "oldMatrix" is not required by all implementations of this function though (e.g the NavMesh generator).
            
             The matrix the graph is transformed with is typically stored in the #matrix field, so the typical usage for this method is
             \code
             var myNewMatrix = Matrix4x4.TRS (...);
             myGraph.RelocateNodes (myGraph.matrix, myNewMatrix);
             \endcode
            
             So for example if you want to move all your nodes in e.g a point graph 10 units along the X axis from the initial position
             \code
             var graph = AstarPath.astarData.pointGraph;
             var m = Matrix4x4.TRS (new Vector3(10,0,0), Quaternion.identity, Vector3.one);
             graph.RelocateNodes (graph.matrix, m);
             \endcode
            
             \note For grid graphs it is recommended to use the helper method RelocateNodes which takes parameters for
             center and nodeSize (and additional parameters) instead since it is both easier to use and is less likely
             to mess up pathfinding.
            
             \warning This method is lossy, so calling it many times may cause node positions to lose precision.
             For example if you set the scale to 0 in one call, and then to 1 in the next call, it will not be able to
             recover the correct positions since when the scale was 0, all nodes were scaled/moved to the same point.
             The same thing happens for other - less extreme - values as well, but to a lesser degree.
            
             \version Prior to version 3.6.1 the oldMatrix and newMatrix parameters were reversed by mistake.
        </member>
        <member name="M:Pathfinding.NavGraph.GetNearest(UnityEngine.Vector3)">
            Returns the nearest node to a position using the default NNConstraint.
            \param position The position to try to find a close node to
            \see Pathfinding.NNConstraint.None
        </member>
        <member name="M:Pathfinding.NavGraph.GetNearest(UnityEngine.Vector3,Pathfinding.NNConstraint)">
            Returns the nearest node to a position using the specified NNConstraint.
            \param position The position to try to find a close node to
            \param constraint Can for example tell the function to try to return a walkable node. If you do not get a good node back, consider calling GetNearestForce. 
        </member>
        <member name="M:Pathfinding.NavGraph.GetNearest(UnityEngine.Vector3,Pathfinding.NNConstraint,Pathfinding.GraphNode)">
            Returns the nearest node to a position using the specified NNConstraint.
            \param position The position to try to find a close node to
            \param hint Can be passed to enable some graph generators to find the nearest node faster.
            \param constraint Can for example tell the function to try to return a walkable node. If you do not get a good node back, consider calling GetNearestForce. 
        </member>
        <member name="M:Pathfinding.NavGraph.GetNearestForce(UnityEngine.Vector3,Pathfinding.NNConstraint)">
            Returns the nearest node to a position using the specified \link Pathfinding.NNConstraint constraint \endlink.
            \returns an NNInfo. This method will only return an empty NNInfo if there are no nodes which comply with the specified constraint.
        </member>
        <member name="M:Pathfinding.NavGraph.Awake">
            This will be called on the same time as Awake on the gameObject which the AstarPath script is attached to. (remember, not in the editor)
            Use this for any initialization code which can't be placed in Scan
        </member>
        <member name="M:Pathfinding.NavGraph.OnDestroy">
            Function for cleaning up references.
            This will be called on the same time as OnDisable on the gameObject which the AstarPath script is attached to (remember, not in the editor).
            Use for any cleanup code such as cleaning up static variables which otherwise might prevent resources from being collected.
            Use by creating a function overriding this one in a graph class, but always call base.OnDestroy () in that function.
            All nodes should be destroyed in this function otherwise a memory leak will arise.
        </member>
        <member name="M:Pathfinding.NavGraph.ScanInternal">
            Internal method for scanning graphs 
        </member>
        <member name="M:Pathfinding.NavGraph.ScanInternal(OnScanStatus)">
            Scans the graph, called from AstarPath.ScanLoop.
            Override this function to implement custom scanning logic
            The statusCallback may be optionally called to show progress info in the editor
        </member>
        <member name="M:Pathfinding.NavGraph.SerializeExtraInfo(Pathfinding.Serialization.GraphSerializationContext)">
            Serializes graph type specific node data.
            This function can be overriden to serialize extra node information (or graph information for that matter)
            which cannot be serialized using the standard serialization.
            Serialize the data in any way you want and return a byte array.
            When loading, the exact same byte array will be passed to the DeserializeExtraInfo function.\n
            These functions will only be called if node serialization is enabled.\n
        </member>
        <member name="M:Pathfinding.NavGraph.DeserializeExtraInfo(Pathfinding.Serialization.GraphSerializationContext)">
            Deserializes graph type specific node data.
            \see SerializeExtraInfo
        </member>
        <member name="M:Pathfinding.NavGraph.PostDeserialization">
            Called after all deserialization has been done for all graphs.
            Can be used to set up more graph data which is not serialized
        </member>
        <member name="M:Pathfinding.NavGraph.InSearchTree(Pathfinding.GraphNode,Pathfinding.Path)">
            Returns if the node is in the search tree of the path.
            Only guaranteed to be correct if \a path is the latest path calculated.
            Use for gizmo drawing only.
        </member>
        <member name="M:Pathfinding.NavGraph.OnDrawGizmos(System.Boolean)">
            Draw gizmos for the graph 
        </member>
        <member name="M:Pathfinding.NavGraph.UnloadGizmoMeshes">
            Called when temporary meshes used in OnDrawGizmos need to be unloaded to prevent memory leaks 
        </member>
        <member name="T:Pathfinding.GraphCollision">
            Handles collision checking for graphs.
            Mostly used by grid based graphs 
        </member>
        <member name="F:Pathfinding.GraphCollision.type">
            Collision shape to use.
            Pathfinding.ColliderType 
        </member>
        <member name="F:Pathfinding.GraphCollision.diameter">
            Diameter of capsule or sphere when checking for collision.
            1 equals \link Pathfinding.GridGraph.nodeSize nodeSize \endlink.
            If #type is set to Ray, this does not affect anything 
        </member>
        <member name="F:Pathfinding.GraphCollision.height">
            Height of capsule or length of ray when checking for collision.
            If #type is set to Sphere, this does not affect anything
        </member>
        <member name="F:Pathfinding.GraphCollision.rayDirection">
            Direction of the ray when checking for collision.
            If #type is not Ray, this does not affect anything
            \note This variable is not used currently, it does not affect anything
        </member>
        <member name="F:Pathfinding.GraphCollision.mask">
            Layer mask to use for collision check.
            This should only contain layers of objects defined as obstacles 
        </member>
        <member name="F:Pathfinding.GraphCollision.heightMask">
            Layer mask to use for height check. 
        </member>
        <member name="F:Pathfinding.GraphCollision.fromHeight">
            The height to check from when checking height 
        </member>
        <member name="F:Pathfinding.GraphCollision.thickRaycast">
            Toggles thick raycast 
        </member>
        <member name="F:Pathfinding.GraphCollision.thickRaycastDiameter">
            Diameter of the thick raycast in nodes.
            1 equals \link Pathfinding.GridGraph.nodeSize nodeSize \endlink 
        </member>
        <member name="F:Pathfinding.GraphCollision.unwalkableWhenNoGround">
            Make nodes unwalkable when no ground was found with the height raycast. If height raycast is turned off, this doesn't affect anything. 
        </member>
        <member name="F:Pathfinding.GraphCollision.use2D">
            Use Unity 2D Physics API.
            \see http://docs.unity3d.com/ScriptReference/Physics2D.html
        </member>
        <member name="F:Pathfinding.GraphCollision.collisionCheck">
            Toggle collision check 
        </member>
        <member name="F:Pathfinding.GraphCollision.heightCheck">
            Toggle height check. If false, the grid will be flat 
        </member>
        <member name="F:Pathfinding.GraphCollision.up">
            Direction to use as \a UP.
            \see Initialize 
        </member>
        <member name="F:Pathfinding.GraphCollision.upheight">
            #up * #height.
            \see Initialize 
        </member>
        <member name="F:Pathfinding.GraphCollision.finalRadius">
            #diameter * scale * 0.5.
            Where \a scale usually is \link Pathfinding.GridGraph.nodeSize nodeSize \endlink
            \see Initialize 
        </member>
        <member name="F:Pathfinding.GraphCollision.finalRaycastRadius">
            #thickRaycastDiameter * scale * 0.5. Where \a scale usually is \link Pathfinding.GridGraph.nodeSize nodeSize \endlink \see Initialize 
        </member>
        <member name="F:Pathfinding.GraphCollision.RaycastErrorMargin">
            Offset to apply after each raycast to make sure we don't hit the same point again in CheckHeightAll 
        </member>
        <member name="M:Pathfinding.GraphCollision.Initialize(UnityEngine.Matrix4x4,System.Single)">
            Sets up several variables using the specified matrix and scale.
            \see GraphCollision.up
            \see GraphCollision.upheight
            \see GraphCollision.finalRadius
            \see GraphCollision.finalRaycastRadius
        </member>
        <member name="M:Pathfinding.GraphCollision.Check(UnityEngine.Vector3)">
            Returns if the position is obstructed.
            If #collisionCheck is false, this will always return true.\n
        </member>
        <member name="M:Pathfinding.GraphCollision.CheckHeight(UnityEngine.Vector3)">
            Returns the position with the correct height. If #heightCheck is false, this will return \a position.\n 
        </member>
        <member name="M:Pathfinding.GraphCollision.CheckHeight(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Boolean@)">
            Returns the position with the correct height.
            If #heightCheck is false, this will return \a position.\n
            \a walkable will be set to false if nothing was hit.
            The ray will check a tiny bit further than to the grids base to avoid floating point errors when the ground is exactly at the base of the grid 
        </member>
        <member name="M:Pathfinding.GraphCollision.Raycast(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Boolean@)">
            Same as #CheckHeight, except that the raycast will always start exactly at \a origin.
            \a walkable will be set to false if nothing was hit.
            The ray will check a tiny bit further than to the grids base to avoid floating point errors when the ground is exactly at the base of the grid 
        </member>
        <member name="M:Pathfinding.GraphCollision.CheckHeightAll(UnityEngine.Vector3)">
            Returns all hits when checking height for \a position.
            \warning Does not work well with thick raycast, will only return an object a single time
        </member>
        <member name="T:Pathfinding.ColliderType">
            Determines collision check shape 
        </member>
        <!-- Badly formed XML comment ignored for member "F:Pathfinding.ColliderType.Capsule" -->
        <!-- Badly formed XML comment ignored for member "F:Pathfinding.ColliderType.Ray" -->
        <member name="T:Pathfinding.RayDirection">
            Determines collision check ray direction 
        </member>
        <!-- Badly formed XML comment ignored for member "F:Pathfinding.RayDirection.Down" -->
        <!-- Badly formed XML comment ignored for member "F:Pathfinding.RayDirection.Both" -->
        <member name="M:Pathfinding.GridGraph.OnDestroy">
            This function will be called when this graph is destroyed 
        </member>
        <member name="P:Pathfinding.GridGraph.uniformWidthDepthGrid">
            This is placed here so generators inheriting from this one can override it and set it to false.
            If it is true, it means that the nodes array's length will always be equal to width*depth
            It is used mainly in the editor to do auto-scanning calls, setting it to false for a non-uniform grid will reduce the number of scans 
        </member>
        <member name="F:Pathfinding.GridGraph.width">
            \name Inspector - Settings
            \{ 
            Width of the grid in nodes. \see UpdateSizeFromWidthDepth 
        </member>
        <member name="F:Pathfinding.GridGraph.depth">
            Depth (height) of the grid in nodes. \see UpdateSizeFromWidthDepth 
        </member>
        <member name="F:Pathfinding.GridGraph.aspectRatio">
            Scaling of the graph along the X axis.
            This should be used if you want different scales on the X and Y axis of the grid
        </member>
        <member name="F:Pathfinding.GridGraph.isometricAngle">
            Angle to use for the isometric projection.
             If you are making a 2D isometric game, you may want to use this parameter to adjust the layout of the graph to match your game.
             This will essentially scale the graph along one of its diagonals to produce something like this:
            
             A perspective view of an isometric graph.
             \shadowimage{isometric/isometric_perspective.png}
            
             A top down view of an isometric graph. Note that the graph is entirely 2D, there is no perspective in this image.
             \shadowimage{isometric/isometric_top.png}
            
             Usually the angle that you want to use is either 30 degrees (alternatively 90-30 = 60 degrees) or atan(1/sqrt(2)) which is approximately 35.264 degrees (alternatively 90 - 35.264 = 54.736 degrees).
             You might also want to rotate the graph plus or minus 45 degrees around the Y axis to get the oritientation required for your game.
            
             You can read more about it on the wikipedia page linked below.
            
             \see http://en.wikipedia.org/wiki/Isometric_projection
             \see rotation
        </member>
        <member name="F:Pathfinding.GridGraph.uniformEdgeCosts">
            If true, all edge costs will be set to the same value.
            If false, diagonals will cost more.
            This is useful for a hexagon graph where the diagonals are actually the same length as the
            normal edges (since the graph has been skewed)
        </member>
        <member name="F:Pathfinding.GridGraph.rotation">
            Rotation of the grid in degrees 
        </member>
        <member name="F:Pathfinding.GridGraph.center">
            Center point of the grid 
        </member>
        <member name="F:Pathfinding.GridGraph.unclampedSize">
            Size of the grid. Might be negative or smaller than #nodeSize 
        </member>
        <member name="F:Pathfinding.GridGraph.nodeSize">
            Size of one node in world units.
            \see UpdateSizeFromWidthDepth
        </member>
        <member name="F:Pathfinding.GridGraph.collision">
            Settings on how to check for walkability and height 
        </member>
        <member name="F:Pathfinding.GridGraph.maxClimb">
            The max position difference between two nodes to enable a connection.
            Set to 0 to ignore the value.
        </member>
        <member name="F:Pathfinding.GridGraph.maxClimbAxis">
            The axis to use for #maxClimb. X = 0, Y = 1, Z = 2. 
        </member>
        <member name="F:Pathfinding.GridGraph.maxSlope">
            The max slope in degrees for a node to be walkable. 
        </member>
        <member name="P:Pathfinding.GridGraph.useRaycastNormal">
            Use heigh raycasting normal for max slope calculation.
            True if #maxSlope is less than 90 degrees.
        </member>
        <member name="F:Pathfinding.GridGraph.erodeIterations">
            Erosion of the graph.
             The graph can be eroded after calculation.
             This means a margin is put around unwalkable nodes or other unwalkable connections.
             It is really good if your graph contains ledges where the nodes without erosion are walkable too close to the edge.
            
             Below is an image showing a graph with erode iterations 0, 1 and 2
             \shadowimage{erosion.png}
            
             \note A high number of erode iterations can seriously slow down graph updates during runtime (GraphUpdateObject)
             and should be kept as low as possible.
             \see erosionUseTags
        </member>
        <member name="F:Pathfinding.GridGraph.erosionUseTags">
            Use tags instead of walkability for erosion.
            Tags will be used for erosion instead of marking nodes as unwalkable. The nodes will be marked with tags in an increasing order starting with the tag #erosionFirstTag.
            Debug with the Tags mode to see the effect. With this enabled you can in effect set how close different AIs are allowed to get to walls using the Valid Tags field on the Seeker component.
            \shadowimage{erosionTags.png}
            \shadowimage{erosionTags2.png}
            \see erosionFirstTag
        </member>
        <member name="F:Pathfinding.GridGraph.erosionFirstTag">
            Tag to start from when using tags for erosion.
            \see #erosionUseTags
            \see #erodeIterations
        </member>
        <member name="F:Pathfinding.GridGraph.autoLinkGrids">
             Auto link the graph's edge nodes together with other GridGraphs in the scene on Scan.
             \warning This feature is experimental and it is currently disabled.
            
             \see #autoLinkDistLimit 
        </member>
        <member name="F:Pathfinding.GridGraph.autoLinkDistLimit">
             Distance limit for grid graphs to be auto linked.
             \warning This feature is experimental and it is currently disabled.
            
             \see #autoLinkGrids 
        </member>
        <member name="F:Pathfinding.GridGraph.neighbours">
            Number of neighbours for each node.
             Either four, six, eight connections per node.
            
             Six connections is primarily for emulating hexagon graphs.
        </member>
        <member name="F:Pathfinding.GridGraph.cutCorners">
            If disabled, will not cut corners on obstacles.
            If \link #neighbours connections \endlink is Eight, obstacle corners might be cut by a connection,
            setting this to false disables that. \image html images/cutCorners.png
        </member>
        <member name="F:Pathfinding.GridGraph.penaltyPositionOffset">
            Offset for the position when calculating penalty.
            \see penaltyPosition 
        </member>
        <member name="F:Pathfinding.GridGraph.penaltyPosition">
            Use position (y-coordinate) to calculate penalty 
        </member>
        <member name="F:Pathfinding.GridGraph.penaltyPositionFactor">
            Scale factor for penalty when calculating from position.
            \see penaltyPosition
        </member>
        <member name="F:Pathfinding.GridGraph.penaltyAngleFactor">
            How much penalty is applied depending on the slope of the terrain.
            At a 90 degree slope (not that exactly 90 degree slopes can occur, but almost 90 degree), this penalty is applied.
            At a 45 degree slope, half of this is applied and so on.
            Note that you may require very large values, a value of 1000 is equivalent to the cost of moving 1 world unit.
        </member>
        <member name="F:Pathfinding.GridGraph.penaltyAnglePower">
            How much extra to penalize very steep angles 
        </member>
        <member name="P:Pathfinding.GridGraph.size">
            \} 
            Size of the grid. Will always be positive and larger than #nodeSize.
            \see #GenerateMatrix
        </member>
        <member name="F:Pathfinding.GridGraph.neighbourOffsets">
            Index offset to get neighbour nodes. Added to a node's index to get a neighbour node index.
            
             \code
                     Z
                     |
                     |
            
                  6  2  5
                   \ | /
             --  3 - X - 1  ----- X
                   / | \
                  7  0  4
            
                     |
                     |
             \endcode
        </member>
        <member name="F:Pathfinding.GridGraph.neighbourCosts">
            Costs to neighbour nodes 
        </member>
        <member name="F:Pathfinding.GridGraph.neighbourXOffsets">
            Offsets in the X direction for neighbour nodes. Only 1, 0 or -1 
        </member>
        <member name="F:Pathfinding.GridGraph.neighbourZOffsets">
            Offsets in the Z direction for neighbour nodes. Only 1, 0 or -1 
        </member>
        <member name="F:Pathfinding.GridGraph.hexagonNeighbourIndices">
            Which neighbours are going to be used when #neighbours=6 
        </member>
        <member name="F:Pathfinding.GridGraph.getNearestForceOverlap">
            In GetNearestForce, determines how far to search after a valid node has been found 
        </member>
        <member name="F:Pathfinding.GridGraph.nodes">
            All nodes in this graph.
             Nodes are laid out row by row.
            
             The first node has grid coordinates X=0, Z=0, the second one X=1, Z=0\n
             the last one has grid coordinates X=width-1, Z=depth-1.
            
             \see GetNodes
        </member>
        <member name="M:Pathfinding.GridGraph.RelocateNodes(UnityEngine.Vector3,UnityEngine.Quaternion,System.Single,System.Single,System.Single)">
            Relocate the grid graph using new settings.
             This will move all nodes in the graph to new positions which matches the new settings.
            
             \warning This method is lossy, so calling it many times may cause node positions to lose precision.
             For example if you set the nodeSize to 0 in one call, and then to 1 in the next call, it will not be able to
             recover the correct positions since when the nodeSize was 0, all nodes were scaled/moved to the same point.
             The same thing happens for other - less extreme - values as well, but to a lesser degree.
            
        </member>
        <member name="M:Pathfinding.GridGraph.GraphPointToWorld(System.Int32,System.Int32,System.Single)">
            Transform a point in graph space to world space.
            This will give you the node position for the node at the given x and z coordinate
            if it is at the specified height above the base of the graph.
        </member>
        <member name="M:Pathfinding.GridGraph.GetNodeConnection(System.Int32,System.Int32,System.Int32,System.Int32)">
            Get the connecting node from the node at (x,z) in the specified direction.
             \returns A GridNode if the node has a connection to that node. Null if no connection in that direction exists
            
             \see GridNode
        </member>
        <member name="M:Pathfinding.GridGraph.SetNodeConnection(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            Set if connection in the specified direction should be enabled.
             Note that bounds checking will still be done when getting the connection value again,
             so it is not necessarily true that HasNodeConnection will return true just because you used
             SetNodeConnection on a node to set a connection to true.
            
             \param index Index of the node
             \param x X coordinate of the node
             \param z Z coordinate of the node
             \param value Enable or disable the connection
            
             \note This is identical to Pathfinding.Node.SetConnectionInternal
            
             \deprecated
        </member>
        <member name="M:Pathfinding.GridGraph.UpdateSizeFromWidthDepth">
            Updates #size from #width, #depth and #nodeSize values. Also \link GenerateMatrix generates a new matrix \endlink.
            \note This does not rescan the graph, that must be done with Scan 
        </member>
        <member name="M:Pathfinding.GridGraph.GenerateMatrix">
            Generates the matrix used for translating nodes from grid coordinates to world coordintes. 
        </member>
        <member name="M:Pathfinding.GridGraph.SetUpOffsetsAndCosts">
            Sets up #neighbourOffsets with the current settings. #neighbourOffsets, #neighbourCosts, #neighbourXOffsets and #neighbourZOffsets are set up.\n
            The cost for a non-diagonal movement between two adjacent nodes is RoundToInt (#nodeSize * Int3.Precision)\n
            The cost for a diagonal movement between two adjacent nodes is RoundToInt (#nodeSize * Sqrt (2) * Int3.Precision)
        </member>
        <member name="M:Pathfinding.GridGraph.UpdateNodePositionCollision(Pathfinding.GridNode,System.Int32,System.Int32,System.Boolean)">
            Updates position, walkability and penalty for the node.
            Assumes that collision.Initialize (...) has been called before this function 
        </member>
        <member name="M:Pathfinding.GridGraph.ErodeWalkableArea">
            Erodes the walkable area.
            \see #erodeIterations
        </member>
        <member name="M:Pathfinding.GridGraph.ErosionAnyFalseConnections(Pathfinding.GridNode)">
            True if the node has any blocked connections.
            For 4 and 8 neighbours the 4 axis aligned connections will be checked.
            For 6 neighbours all 6 neighbours will be checked.
        </member>
        <member name="M:Pathfinding.GridGraph.ErodeWalkableArea(System.Int32,System.Int32,System.Int32,System.Int32)">
            Erodes the walkable area.
            
             xmin, zmin (inclusive)\n
             xmax, zmax (exclusive)
            
             \see #erodeIterations 
        </member>
        <member name="M:Pathfinding.GridGraph.IsValidConnection(Pathfinding.GridNode,Pathfinding.GridNode)">
            Returns true if a connection between the adjacent nodes \a n1 and \a n2 is valid.
             Also takes into account if the nodes are walkable.
            
             This method may be overriden if you want to customize what connections are valid.
             It must however hold that IsValidConnection(a,b) == IsValidConnection(b,a).
            
             This is used for calculating the connections when the graph is scanned or updated.
            
             \see CalculateConnections
        </member>
        <member name="M:Pathfinding.GridGraph.CalculateConnections(Pathfinding.GridNode)">
            Calculates the grid connections for a single node.
            Convenience function, it's faster to use CalculateConnections(int,int,GridNode)
            but that will only show when calculating for a large number of nodes.
            \todo Test this function, should work ok, but you never know
        </member>
        <member name="M:Pathfinding.GridGraph.CalculateConnections(Pathfinding.GridNode[],System.Int32,System.Int32,Pathfinding.GridNode)">
            Calculates the grid connections for a single node.
            \deprecated CalculateConnections no longer takes a node array, it just uses the one on the graph
        </member>
        <member name="M:Pathfinding.GridGraph.CalculateConnections(System.Int32,System.Int32,Pathfinding.GridNode)">
            Calculates the grid connections for a single node.
             The x and z parameters are assumed to be the grid coordinates of the node.
            
             \see CalculateConnections(GridNode)
        </member>
        <member name="M:Pathfinding.GridGraph.OnPostScan(AstarPath)">
            Auto links grid graphs together. Called after all graphs have been scanned.
            \see autoLinkGrids
        </member>
        <member name="M:Pathfinding.GridGraph.GetBoundsMinMax(UnityEngine.Bounds,UnityEngine.Matrix4x4,UnityEngine.Vector3@,UnityEngine.Vector3@)">
            Calculates minimum and maximum points for bounds \a b when multiplied with the matrix 
        </member>
        <member name="M:Pathfinding.GridGraph.GetNodesInArea(UnityEngine.Bounds)">
            All nodes inside the bounding box.
             \note Be nice to the garbage collector and release the list when you have used it (optional)
             \see Pathfinding.Util.ListPool
            
             \see GetNodesInArea(GraphUpdateShape)
        </member>
        <member name="M:Pathfinding.GridGraph.GetNodesInArea(Pathfinding.GraphUpdateShape)">
            All nodes inside the shape.
             \note Be nice to the garbage collector and release the list when you have used it (optional)
             \see Pathfinding.Util.ListPool
            
             \see GetNodesInArea(Bounds)
        </member>
        <member name="M:Pathfinding.GridGraph.GetNodesInArea(UnityEngine.Bounds,Pathfinding.GraphUpdateShape)">
            All nodes inside the shape or if null, the bounding box.
            If a shape is supplied, it is assumed to be contained inside the bounding box.
            \see GraphUpdateShape.GetBounds
        </member>
        <member name="M:Pathfinding.GridGraph.UpdateArea(Pathfinding.GraphUpdateObject)">
            Internal function to update an area of the graph 
        </member>
        <member name="M:Pathfinding.GridGraph.CheckConnection(Pathfinding.GridNode,System.Int32)">
            Returns if \a node is connected to it's neighbour in the specified direction.
             This will also return true if #neighbours = NumNeighbours.Four, the direction is diagonal and one can move through one of the adjacent nodes
             to the targeted node.
            
             \see neighbourOffsets
        </member>
        <member name="T:Pathfinding.NumNeighbours">
            Number of neighbours for a single grid node.
            \since The 'Six' item was added in 3.6.1
        </member>
        <member name="F:Pathfinding.NavMeshGraph.sourceMesh">
            Mesh to construct navmesh from 
        </member>
        <member name="F:Pathfinding.NavMeshGraph.offset">
            Offset in world space 
        </member>
        <member name="F:Pathfinding.NavMeshGraph.rotation">
            Rotation in degrees 
        </member>
        <member name="F:Pathfinding.NavMeshGraph.scale">
            Scale of the graph 
        </member>
        <member name="F:Pathfinding.NavMeshGraph.accurateNearestNode">
            More accurate nearest node queries.
            When on, looks for the closest point on every triangle instead of if point is inside the node triangle in XZ space.
            This is slower, but a lot better if your mesh contains overlaps (e.g bridges over other areas of the mesh).
            Note that for maximum effect the Full Get Nearest Node Search setting should be toggled in A* Inspector Settings.
        </member>
        <member name="F:Pathfinding.NavMeshGraph._bbTree">
            Bounding Box Tree. Enables really fast lookups of nodes. \astarpro 
        </member>
        <member name="M:Pathfinding.NavMeshGraph.RelocateNodes(UnityEngine.Matrix4x4,UnityEngine.Matrix4x4)">
            Transforms the nodes using newMatrix from their initial positions.
            The "oldMatrix" variable can be left out in this function call (only for this graph generator)
            since the information can be taken from other saved data, which gives better precision.
        </member>
        <member name="M:Pathfinding.NavMeshGraph.GetNearestForce(UnityEngine.Vector3,Pathfinding.NNConstraint)">
            This performs a linear search through all polygons returning the closest one.
            This is usually only called in the Free version of the A* Pathfinding Project since the Pro one supports BBTrees and will do another query
        </member>
        <member name="M:Pathfinding.NavMeshGraph.GetNearestForce(Pathfinding.NavGraph,Pathfinding.INavmeshHolder,UnityEngine.Vector3,Pathfinding.NNConstraint,System.Boolean)">
            This performs a linear search through all polygons returning the closest one 
        </member>
        <member name="M:Pathfinding.NavMeshGraph.GetNearestForceBoth(Pathfinding.NavGraph,Pathfinding.INavmeshHolder,UnityEngine.Vector3,Pathfinding.NNConstraint,System.Boolean)">
            This performs a linear search through all polygons returning the closest one.
            This will fill the NNInfo with .node for the closest node not necessarily complying with the NNConstraint, and .constrainedNode with the closest node
            complying with the NNConstraint.
            \see GetNearestForce(Node[],Int3[],Vector3,NNConstraint,bool)
        </member>
        <member name="M:Pathfinding.NavMeshGraph.ClosestPointOnNode(Pathfinding.TriangleMeshNode,Pathfinding.Int3[],UnityEngine.Vector3)">
            Returns the closest point of the node.
             The only reason this is here is because it is slightly faster compared to TriangleMeshNode.ClosestPointOnNode
             since it doesn't involve so many indirections.
            
             Use TriangleMeshNode.ClosestPointOnNode in most other cases.
        </member>
        <member name="M:Pathfinding.NavMeshGraph.ContainsPoint(Pathfinding.TriangleMeshNode,UnityEngine.Vector3)">
            Returns if the point is inside the node in XZ space 
        </member>
        <member name="M:Pathfinding.NavMeshGraph.ContainsPoint(Pathfinding.TriangleMeshNode,UnityEngine.Vector3,Pathfinding.Int3[])">
            Returns if the point is inside the node in XZ space 
        </member>
        <member name="M:Pathfinding.NavMeshGraph.ScanInternal(System.String)">
            Scans the graph using the path to an .obj mesh 
        </member>
        <member name="M:Pathfinding.NavMeshGraph.GenerateNodes(UnityEngine.Vector3[],System.Int32[],UnityEngine.Vector3[]@,Pathfinding.Int3[]@)">
            Generates a navmesh. Based on the supplied vertices and triangles 
        </member>
        <member name="M:Pathfinding.NavMeshGraph.RebuildBBTree(Pathfinding.NavMeshGraph)">
            Rebuilds the BBTree on a NavGraph.
            \astarpro
            \see NavMeshGraph.bbTree 
        </member>
        <member name="T:Pathfinding.GridNodeBase">
            Base class for GridNode and LevelGridNode 
        </member>
        <member name="P:Pathfinding.GridNodeBase.NodeInGridIndex">
            The index of the node in the grid.
            This is x + z*graph.width
            So you can get the X and Z indices using
            \code
            int index = node.NodeInGridIndex;
            int x = index % graph.width;
            int z = index / graph.width;
            // where graph is GridNode.GetGridGraph (node.graphIndex), i.e the graph the nodes are contained in.
            \endcode
        </member>
        <member name="P:Pathfinding.GridNode.InternalGridFlags">
            Internal use only 
        </member>
        <member name="M:Pathfinding.GridNode.GetConnectionInternal(System.Int32)">
            Returns true if the node has a connection in the specified direction.
             The dir parameter corresponds to directions in the grid as:
             \code
             [0] = -Y
             [1] = +X
             [2] = +Y
             [3] = -X
             [4] = -Y+X
             [5] = +Y+X
             [6] = +Y-X
             [7] = -Y-X
             \endcode
            
             \see SetConnectionInternal
        </member>
        <member name="M:Pathfinding.GridNode.SetConnectionInternal(System.Int32,System.Boolean)">
            Enables or disables a connection in a specified direction on the graph.
            \see GetConnectionInternal
        </member>
        <member name="M:Pathfinding.GridNode.SetAllConnectionInternal(System.Int32)">
            Sets the state of all grid connections.
             \param connections a bitmask of the connections (bit 0 is the first connection, etc.).
            
             \see SetConnectionInternal
        </member>
        <member name="M:Pathfinding.GridNode.ResetConnectionsInternal">
            Disables all grid connections from this node.
            \note Other nodes might still be able to get to this node.
            Therefore it is recommended to also disable the relevant connections on adjacent nodes.
        </member>
        <member name="P:Pathfinding.GridNode.WalkableErosion">
            Stores walkability before erosion is applied.
            Used by graph updating.
        </member>
        <member name="P:Pathfinding.GridNode.TmpWalkable">
            Temporary variable used by graph updating 
        </member>
        <member name="M:Pathfinding.GridNode.AddConnection(Pathfinding.GraphNode,System.UInt32)">
            Add a connection from this node to the specified node.
             If the connection already exists, the cost will simply be updated and
             no extra connection added.
            
             \note Only adds a one-way connection. Consider calling the same function on the other node
             to get a two-way connection.
        </member>
        <member name="M:Pathfinding.GridNode.RemoveConnection(Pathfinding.GraphNode)">
            Removes any connection from this node to the specified node.
             If no such connection exists, nothing will be done.
            
             \note This only removes the connection from this node to the other node.
             You may want to call the same function on the other node to remove its eventual connection
             to this node.
        </member>
        <member name="F:Pathfinding.PointNode.gameObject">
            GameObject this node was created from (if any).
            \warning When loading a graph from a saved file or from cache, this field will be null.
        </member>
        <member name="F:Pathfinding.PointNode.next">
            Used for internal linked list structure.
            \warning Do not modify
        </member>
        <member name="M:Pathfinding.PointNode.AddConnection(Pathfinding.GraphNode,System.UInt32)">
            Add a connection from this node to the specified node.
             If the connection already exists, the cost will simply be updated and
             no extra connection added.
            
             \note Only adds a one-way connection. Consider calling the same function on the other node
             to get a two-way connection.
        </member>
        <member name="M:Pathfinding.PointNode.RemoveConnection(Pathfinding.GraphNode)">
            Removes any connection from this node to the specified node.
             If no such connection exists, nothing will be done.
            
             \note This only removes the connection from this node to the other node.
             You may want to call the same function on the other node to remove its eventual connection
             to this node.
        </member>
        <member name="T:Pathfinding.TriangleMeshNode">
            Node represented by a triangle 
        </member>
        <member name="F:Pathfinding.TriangleMeshNode.v0">
            Internal vertex index for the first vertex 
        </member>
        <member name="F:Pathfinding.TriangleMeshNode.v1">
            Internal vertex index for the second vertex 
        </member>
        <member name="F:Pathfinding.TriangleMeshNode.v2">
            Internal vertex index for the third vertex 
        </member>
        <member name="M:Pathfinding.TriangleMeshNode.SetNavmeshHolder(System.Int32,Pathfinding.INavmeshHolder)">
            Sets the internal navmesh holder for a given graph index.
            \warning Internal method
        </member>
        <member name="M:Pathfinding.TriangleMeshNode.UpdatePositionFromVertices">
            Set the position of this node to the average of its 3 vertices 
        </member>
        <member name="M:Pathfinding.TriangleMeshNode.GetVertexIndex(System.Int32)">
            Return a number identifying a vertex.
            This number does not necessarily need to be a index in an array but two different vertices (in the same graph) should
            not have the same vertex numbers.
        </member>
        <member name="M:Pathfinding.TriangleMeshNode.GetVertexArrayIndex(System.Int32)">
            Return a number specifying an index in the source vertex array.
            The vertex array can for example be contained in a recast tile, or be a navmesh graph, that is graph dependant.
            This is slower than GetVertexIndex, if you only need to compare vertices, use GetVertexIndex.
        </member>
        <member name="M:Pathfinding.TriangleMeshNode.SharedEdge(Pathfinding.GraphNode)">
            Returns the edge which is shared with \a other.
            If no edge is shared, -1 is returned.
            The edge is GetVertex(result) - GetVertex((result+1) % GetVertexCount()).
            See GetPortal for the exact segment shared.
            \note Might return that an edge is shared when the two nodes are in different tiles and adjacent on the XZ plane, but on the Y-axis.
            Therefore it is recommended that you only test for neighbours of this node or do additional checking afterwards.
        </member>
        <member name="T:Pathfinding.PointGraph">
            Basic point graph.
             \ingroup graphs
             The List graph is the most basic graph structure, it consists of a number of interconnected points in space, waypoints or nodes.\n
             The list graph takes a Transform object as "root", this Transform will be searched for child objects, every child object will be treated as a node.
             It will then check if any connections between the nodes can be made, first it will check if the distance between the nodes isn't too large ( #maxDistance )
             and then it will check if the axis aligned distance isn't too high. The axis aligned distance, named #limits,
             is useful because usually an AI cannot climb very high, but linking nodes far away from each other,
             but on the same Y level should still be possible. #limits and #maxDistance won't affect anything if the values are 0 (zero) though. \n
             Lastly it will check if there are any obstructions between the nodes using
             <a href="http://unity3d.com/support/documentation/ScriptReference/Physics.Raycast.html">raycasting</a> which can optionally be thick.\n
             One thing to think about when using raycasting is to either place the nodes a small
             distance above the ground in your scene or to make sure that the ground is not in the raycast \a mask to avoid the raycast from hitting the ground.\n
             \note Does not support linecast because of obvious reasons.
            
             \shadowimage{pointgraph_graph.png}
             \shadowimage{pointgraph_inspector.png}
            
        </member>
        <member name="F:Pathfinding.PointGraph.root">
            Childs of this transform are treated as nodes 
        </member>
        <member name="F:Pathfinding.PointGraph.searchTag">
            If no #root is set, all nodes with the tag is used as nodes 
        </member>
        <member name="F:Pathfinding.PointGraph.maxDistance">
            Max distance for a connection to be valid.
             The value 0 (zero) will be read as infinity and thus all nodes not restricted by
             other constraints will be added as connections.
            
             A negative value will disable any neighbours to be added.
             It will completely stop the connection processing to be done, so it can save you processing
             power if you don't these connections.
        </member>
        <member name="F:Pathfinding.PointGraph.limits">
            Max distance along the axis for a connection to be valid. 0 = infinity 
        </member>
        <member name="F:Pathfinding.PointGraph.raycast">
            Use raycasts to check connections 
        </member>
        <member name="F:Pathfinding.PointGraph.use2DPhysics">
            Use the 2D Physics API 
        </member>
        <member name="F:Pathfinding.PointGraph.thickRaycast">
            Use thick raycast 
        </member>
        <member name="F:Pathfinding.PointGraph.thickRaycastRadius">
            Thick raycast radius 
        </member>
        <member name="F:Pathfinding.PointGraph.recursive">
            Recursively search for childnodes to the #root 
        </member>
        <member name="F:Pathfinding.PointGraph.mask">
            Layer mask to use for raycast 
        </member>
        <member name="F:Pathfinding.PointGraph.nodes">
            All nodes in this graph.
             Note that only the first #nodeCount will be non-null.
            
             You can also use the GetNodes method to get all nodes.
        </member>
        <member name="F:Pathfinding.PointGraph.nodeCount">
            Number of nodes in this graph.
            
             \warning Do not edit directly
        </member>
        <member name="M:Pathfinding.PointGraph.AddNode(Pathfinding.Int3)">
            Add a node to the graph at the specified position.
             \note Vector3 can be casted to Int3 using (Int3)myVector.
            
             \note This needs to be called when it is safe to update nodes, which is
             - when scanning
             - during a graph update
             - inside a callback registered using AstarPath.RegisterSafeUpdate
        </member>
        <member name="M:Pathfinding.PointGraph.AddNode``1(``0,Pathfinding.Int3)">
            Add a node with the specified type to the graph at the specified position.
            
             \param node This must be a node created using T(AstarPath.active) right before the call to this method.
             The node parameter is only there because there is no new(AstarPath) constraint on
             generic type parameters.
             \param position The node will be set to this position.
             \note Vector3 can be casted to Int3 using (Int3)myVector.
            
             \note This needs to be called when it is safe to update nodes, which is
             - when scanning
             - during a graph update
             - inside a callback registered using AstarPath.RegisterSafeUpdate
            
             \see AstarPath.RegisterSafeUpdate
        </member>
        <member name="M:Pathfinding.PointGraph.CountChildren(UnityEngine.Transform)">
            Recursively counds children of a transform 
        </member>
        <member name="M:Pathfinding.PointGraph.AddChildren(System.Int32@,UnityEngine.Transform)">
            Recursively adds childrens of a transform as nodes 
        </member>
        <member name="M:Pathfinding.PointGraph.RebuildNodeLookup">
            Rebuilds the lookup structure for nodes.
            
             This is used when #optimizeForSparseGraph is enabled.
            
             You should call this method every time you move a node in the graph manually and
             you are using #optimizeForSparseGraph, otherwise pathfinding might not work correctly.
            
             \astarpro
        </member>
        <member name="M:Pathfinding.PointGraph.IsValidConnection(Pathfinding.GraphNode,Pathfinding.GraphNode,System.Single@)">
            Returns if the connection between \a a and \a b is valid.
            Checks for obstructions using raycasts (if enabled) and checks for height differences.\n
            As a bonus, it outputs the distance between the nodes too if the connection is valid
        </member>
        <member name="T:Pathfinding.BBTree">
            Axis Aligned Bounding Box Tree.
             Holds a bounding box tree of triangles.
            
             \astarpro
        </member>
        <member name="T:Pathfinding.EuclideanEmbedding">
            Implements heuristic optimizations.
            
             \see heuristic-opt
             \see Game AI Pro - Pathfinding Architecture Optimizations by Steve Rabin and Nathan R. Sturtevant
            
             \astarpro
        </member>
        <member name="F:Pathfinding.EuclideanEmbedding.pivotPointRoot">
            All children of this transform will be used as pivot points 
        </member>
        <member name="F:Pathfinding.AlternativePath.penalty">
            How much penalty (weight) to apply to nodes 
        </member>
        <member name="F:Pathfinding.AlternativePath.randomStep">
            Max number of nodes to skip in a row 
        </member>
        <member name="F:Pathfinding.AlternativePath.prevNodes">
            The previous path 
        </member>
        <member name="F:Pathfinding.AlternativePath.prevSeed">
            Previous seed. Used to figure out which nodes to revert penalty on without storing them in an array 
        </member>
        <member name="F:Pathfinding.AlternativePath.prevPenalty">
            The previous penalty used. Stored just in case it changes during operation 
        </member>
        <member name="F:Pathfinding.AlternativePath.rnd">
            A random object 
        </member>
        <member name="F:Pathfinding.AlternativePath.seedGenerator">
            A random object generating random seeds for other random objects 
        </member>
        <member name="F:Pathfinding.AlternativePath.toBeApplied">
            The nodes waiting to have their penalty changed 
        </member>
        <member name="M:Pathfinding.FunnelModifier.RunFunnel(System.Collections.Generic.List{UnityEngine.Vector3},System.Collections.Generic.List{UnityEngine.Vector3},System.Collections.Generic.List{UnityEngine.Vector3})">
            Calculate a funnel path from the \a left and \a right portal lists.
            The result will be appended to \a funnelPath
        </member>
        <member name="T:Pathfinding.IPathModifier">
            Base for all path modifiers.
            \see MonoModifier
            Modifier 
        </member>
        <member name="T:Pathfinding.PathModifier">
            Base class for path modifiers which are not attached to GameObjects.
            \see MonoModifier 
        </member>
        <member name="P:Pathfinding.PathModifier.Order">
            Modifiers will be executed from lower order to higher order.
            This value is assumed to stay constant.
        </member>
        <member name="M:Pathfinding.PathModifier.Apply(Pathfinding.Path)">
            Main Post-Processing function 
        </member>
        <member name="T:Pathfinding.MonoModifier">
            Base class for path modifiers which can be attached to GameObjects.
            \see[AddComponentMenu("CONTEXT/Seeker/Something")] Modifier
        </member>
        <member name="P:Pathfinding.MonoModifier.Order">
            Modifiers will be executed from lower order to higher order.
            This value is assumed to stay constant.
        </member>
        <member name="M:Pathfinding.MonoModifier.Awake">
            Alerts the Seeker that this modifier exists 
        </member>
        <member name="M:Pathfinding.MonoModifier.Apply(Pathfinding.Path)">
            Main Post-Processing function 
        </member>
        <member name="T:Pathfinding.RaycastModifier">
            Simplifies a path using raycasting.
            \ingroup modifiers
            This modifier will try to remove as many nodes as possible from the path using raycasting (linecasting) to validate the node removal.
            Either graph raycasts or Physics.Raycast 
        </member>
        <member name="F:Pathfinding.RaycastModifier.useGraphRaycasting">
            Use raycasting on the graphs. Only currently works with GridGraph and NavmeshGraph and RecastGraph. \astarpro 
        </member>
        <member name="F:Pathfinding.RaycastModifier.nodes">
            To avoid too many memory allocations. An array is kept between the checks and filled in with the positions instead of allocating a new one every time.
        </member>
        <member name="M:Pathfinding.RaycastModifier.ValidateLine(Pathfinding.GraphNode,Pathfinding.GraphNode,UnityEngine.Vector3,UnityEngine.Vector3)">
            Check if a straight path between v1 and v2 is valid 
        </member>
        <member name="F:Pathfinding.SimpleSmoothModifier.smoothType">
            Type of smoothing to use 
        </member>
        <member name="F:Pathfinding.SimpleSmoothModifier.subdivisions">
            Number of times to subdivide when not using a uniform length 
        </member>
        <member name="F:Pathfinding.SimpleSmoothModifier.iterations">
            Number of times to apply smoothing 
        </member>
        <member name="F:Pathfinding.SimpleSmoothModifier.strength">
            Determines how much smoothing to apply in each smooth iteration. 0.5 usually produces the nicest looking curves. 
        </member>
        <member name="F:Pathfinding.SimpleSmoothModifier.uniformLength">
            Toggle to divide all lines in equal length segments.
            \see #maxSegmentLength
        </member>
        <member name="F:Pathfinding.SimpleSmoothModifier.maxSegmentLength">
            The length of the segments in the smoothed path when using #uniformLength.
            A high value yields rough paths and low value yields very smooth paths, but is slower 
        </member>
        <member name="F:Pathfinding.SimpleSmoothModifier.bezierTangentLength">
            Length factor of the bezier curves' tangents' 
        </member>
        <member name="F:Pathfinding.SimpleSmoothModifier.offset">
            Offset to apply in each smoothing iteration when using Offset Simple. \see #smoothType 
        </member>
        <member name="F:Pathfinding.SimpleSmoothModifier.factor">
            Roundness factor used for CurvedNonuniform 
        </member>
        <member name="F:Pathfinding.StartEndModifier.addPoints">
            Add points to the path instead of replacing them 
        </member>
        <member name="F:Pathfinding.StartEndModifier.adjustStartPoint">
            Will be called when a path is processed.
            The value which is returned will be used as the start point of the path
            and potentially clamped depending on the value of the #exactStartPoint field.
            Only used for the Original, Interpolate and NodeConnection modes.
        </member>
        <member name="T:Pathfinding.StartEndModifier.Exactness">
            Sets where the start and end points of a path should be placed 
        </member>
        <member name="F:Pathfinding.StartEndModifier.Exactness.SnapToNode">
            The point is snapped to the first/last node in the path
        </member>
        <member name="F:Pathfinding.StartEndModifier.Exactness.Original">
            The point is set to the exact point which was passed when calling the pathfinding 
        </member>
        <member name="F:Pathfinding.StartEndModifier.Exactness.Interpolate">
            The point is set to the closest point on the line between either the two first points or the two last points.
            Usually you will want to use the NodeConnection mode instead since that is usually the behaviour that you really want.
        </member>
        <member name="F:Pathfinding.StartEndModifier.Exactness.ClosestOnNode">
            The point is set to the closest point on the node. Note that for some node types (point nodes) the "closest point" is the node's position which makes this identical to Exactness.SnapToNode 
        </member>
        <member name="F:Pathfinding.StartEndModifier.Exactness.NodeConnection">
            The point is set to the closest point on one of the connections from the start/end node 
        </member>
        <member name="T:Pathfinding.RelevantGraphSurface">
            Pruning of recast navmesh regions.
             A RelevantGraphSurface component placed in the scene specifies that
             the navmesh region it is inside should be included in the navmesh.
            
             \see Pathfinding.RecastGraph.relevantGraphSurfaceMode
            
        </member>
        <member name="M:Pathfinding.RelevantGraphSurface.UpdateAllPositions">
            Updates the positions of all relevant graph surface components.
            Required to be able to use the position property reliably.
        </member>
        <member name="T:Pathfinding.ABPath">
            Basic path, finds the shortest path from A to B.
            \ingroup paths
            This is the most basic path object it will try to find the shortest path from A to B.\n
            Many other path types inherit from this type.
            \see Seeker.StartPath
        </member>
        <member name="F:Pathfinding.ABPath.recalcStartEndCosts">
            Defines if start and end nodes will have their connection costs recalculated for this path.
            These connection costs will be more accurate and based on the exact start point and target point,
            however it should not be used when connection costs are not the default ones (all build in graph generators currently generate default connection costs).
            \see Int3.costMagnitude
            \since Added in 3.0.8.3
            \bug Does not do anything in 3.2 and up due to incompabilities with multithreading. Will be enabled again in later versions.
        </member>
        <member name="F:Pathfinding.ABPath.startNode">
            Start node of the path 
        </member>
        <member name="F:Pathfinding.ABPath.endNode">
            End node of the path 
        </member>
        <member name="F:Pathfinding.ABPath.startHint">
            Hints can be set to enable faster Get Nearest Node queries. Only applies to some graph types 
        </member>
        <member name="F:Pathfinding.ABPath.endHint">
            Hints can be set to enable faster Get Nearest Node queries. Only applies to some graph types 
        </member>
        <member name="F:Pathfinding.ABPath.originalStartPoint">
            Start Point exactly as in the path request 
        </member>
        <member name="F:Pathfinding.ABPath.originalEndPoint">
            End Point exactly as in the path request 
        </member>
        <member name="F:Pathfinding.ABPath.startPoint">
            Start point of the path.
            This is the closest point on the #startNode to #originalStartPoint
        </member>
        <member name="F:Pathfinding.ABPath.endPoint">
            End point of the path.
            This is the closest point on the #endNode to #originalEndPoint
        </member>
        <member name="P:Pathfinding.ABPath.hasEndPoint">
            Determines if a search for an end node should be done.
            Set by different path types.
            \since Added in 3.0.8.3
        </member>
        <!-- Badly formed XML comment ignored for member "F:Pathfinding.ABPath.calculatePartial" -->
        <member name="F:Pathfinding.ABPath.partialBestTarget">
            Current best target for the partial path.
            This is the node with the lowest H score.
            \warning This feature is currently a work in progress and may not work in the current version
        </member>
        <member name="F:Pathfinding.ABPath.endNodeCosts">
            Saved original costs for the end node. \see ResetCosts 
        </member>
        <member name="M:Pathfinding.ABPath.#ctor">
            @{ @name Constructors 
            Default constructor.
            Do not use this. Instead use the static Construct method which can handle path pooling.
        </member>
        <member name="M:Pathfinding.ABPath.Construct(UnityEngine.Vector3,UnityEngine.Vector3,OnPathDelegate)">
            Construct a path with a start and end point.
             The delegate will be called when the path has been calculated.
             Do not confuse it with the Seeker callback as they are sent at different times.
             If you are using a Seeker to start the path you can set \a callback to null.
            
             \returns The constructed path object
        </member>
        <member name="M:Pathfinding.ABPath.UpdateStartEnd(UnityEngine.Vector3,UnityEngine.Vector3)">
            @} 
            Sets the start and end points.
            Sets #originalStartPoint, #originalEndPoint, #startPoint, #endPoint, #startIntPoint and #hTarget (to \a end ) 
        </member>
        <member name="M:Pathfinding.ABPath.Reset">
            Reset all values to their default values.
            All inheriting path types must implement this function, resetting ALL their variables to enable recycling of paths.
            Call this base function in inheriting types with base.Reset ();
        </member>
        <member name="M:Pathfinding.ABPath.Prepare">
            Prepares the path. Searches for start and end nodes and does some simple checking if a path is at all possible 
        </member>
        <member name="M:Pathfinding.ABPath.CompletePathIfStartIsValidTarget">
            Checks if the start node is the target and complete the path if that is the case.
             This is necessary so that subclasses (e.g XPath) can override this behaviour.
            
             If the start node is a valid target point, this method should set CompleteState to Complete
             and trace the path.
        </member>
        <member name="M:Pathfinding.ABPath.CalculateStep(System.Int64)">
            Calculates the path until completed or until the time has passed \a targetTick.
             Usually a check is only done every 500 nodes if the time has passed \a targetTick.
             Time/Ticks are got from System.DateTime.UtcNow.Ticks.
            
             Basic outline of what the function does for the standard path (Pathfinding.ABPath).
             \code
             while the end has not been found and no error has ocurred
             check if we have reached the end
             if so, exit and return the path
            
             open the current node, i.e loop through its neighbours, mark them as visited and put them on a heap
            
             check if there are still nodes left to process (or have we searched the whole graph)
             if there are none, flag error and exit
            
             pop the next node of the heap and set it as current
            
             check if the function has exceeded the time limit
             if so, return and wait for the function to get called again
             \endcode
        </member>
        <member name="M:Pathfinding.ABPath.ResetCosts(Pathfinding.Path)">
            Resets End Node Costs. Costs are updated on the end node at the start of the search to better reflect the end point passed to the path, the previous ones are saved in #endNodeCosts and are reset in this function which is called after the path search is complete 
        </member>
        <member name="M:Pathfinding.ABPath.DebugString(PathLog)">
            Returns a debug string for this path.
        </member>
        <member name="M:Pathfinding.ABPath.GetMovementVector(UnityEngine.Vector3)">
            Returns in which direction to move from a point on the path.
            A simple and quite slow (well, compared to more optimized algorithms) algorithm first finds the closest path segment (from #vectorPath) and then returns
            the direction to the next point from there. The direction is not normalized.
            \returns Direction to move from a \a point, returns Vector3.zero if #vectorPath is null or has a length of 0 
        </member>
        <member name="T:Pathfinding.GraphUpdateUtilities">
            Contains useful functions for updating graphs.
             This class works a lot with the Node class, a useful function to get nodes is AstarPath.GetNearest.
            
             \see AstarPath.GetNearest
             \see Pathfinding.Utils.PathUtilities
            
             \since Added in 3.1
            
             \ingroup utils
        </member>
        <!-- Badly formed XML comment ignored for member "M:Pathfinding.GraphUpdateUtilities.UpdateGraphsNoBlock(Pathfinding.GraphUpdateObject,Pathfinding.GraphNode,Pathfinding.GraphNode,System.Boolean)" -->
        <member name="M:Pathfinding.GraphUpdateUtilities.UpdateGraphsNoBlock(Pathfinding.GraphUpdateObject,System.Collections.Generic.List{Pathfinding.GraphNode},System.Boolean)">
            Updates graphs and checks if all nodes are still reachable from each other.
             Graphs are updated, then a check is made to see if the nodes are still reachable from each other.
             If they are not, the graphs are reverted to before the update and \a false is returned.
             This is slower than a normal graph update.
             All queued graph updates and thread safe callbacks will be flushed during this function.
            
             \note This might return true for small areas even if there is no possible path if AstarPath.minAreaSize is greater than zero (0).
             So when using this, it is recommended to set AstarPath.minAreaSize to 0. (A* Inspector -> Settings -> Pathfinding)
            
             \param guo The GraphUpdateObject to update the graphs with
             \param nodes Nodes which should have valid paths between them. All nodes should be walkable or \a false will be returned.
             \param alwaysRevert If true, reverts the graphs to the old state even if no blocking ocurred
            
             \returns True if the given nodes are still reachable from each other after the \a guo has been applied. False otherwise.
        </member>
        <member name="T:Pathfinding.PathUtilities">
            Contains useful functions for working with paths and nodes.
             This class works a lot with the Node class, a useful function to get nodes is AstarPath.GetNearest.
             \see AstarPath.GetNearest
             \see Pathfinding.Utils.GraphUpdateUtilities
             \since Added in version 3.2
             \ingroup utils
            
        </member>
        <member name="M:Pathfinding.PathUtilities.IsPathPossible(Pathfinding.GraphNode,Pathfinding.GraphNode)">
            Returns if there is a walkable path from \a n1 to \a n2.
            If you are making changes to the graph, areas must first be recaculated using FloodFill()
            \note This might return true for small areas even if there is no possible path if AstarPath.minAreaSize is greater than zero (0).
            So when using this, it is recommended to set AstarPath.minAreaSize to 0. (A* Inspector -> Settings -> Pathfinding)
            \see AstarPath.GetNearest
        </member>
        <member name="M:Pathfinding.PathUtilities.IsPathPossible(System.Collections.Generic.List{Pathfinding.GraphNode})">
            Returns if there are walkable paths between all nodes.
             If you are making changes to the graph, areas must first be recaculated using FloodFill()
             \note This might return true for small areas even if there is no possible path if AstarPath.minAreaSize is greater than zero (0).
             So when using this, it is recommended to set AstarPath.minAreaSize to 0. (A* Inspector -> Settings -> Pathfinding)
            
             Returns true for empty lists
            
             \see AstarPath.GetNearest
        </member>
        <member name="M:Pathfinding.PathUtilities.IsPathPossible(System.Collections.Generic.List{Pathfinding.GraphNode},System.Int32)">
            Returns if there are walkable paths between all nodes.
             If you are making changes to the graph, areas should first be recaculated using FloodFill()
            
             This method will actually only check if the first node can reach all other nodes. However this is
             equivalent in 99% of the cases since almost always the graph connections are bidirectional.
             If you are not aware of any cases where you explicitly create unidirectional connections
             this method can be used without worries.
            
             Returns true for empty lists
            
             \warning This method is significantly slower than the IsPathPossible method which does not take a tagMask
            
             \see AstarPath.GetNearest
        </member>
        <!-- Badly formed XML comment ignored for member "M:Pathfinding.PathUtilities.GetReachableNodes(Pathfinding.GraphNode,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Pathfinding.PathUtilities.BFS(Pathfinding.GraphNode,System.Int32,System.Int32)" -->
        <member name="M:Pathfinding.PathUtilities.GetSpiralPoints(System.Int32,System.Single)">
            Returns points in a spiral centered around the origin with a minimum clearance from other points.
             The points are laid out on the involute of a circle
             \see http://en.wikipedia.org/wiki/Involute
             Which has some nice properties.
             All points are separated by \a clearance world units.
             This method is O(n), yes if you read the code you will see a binary search, but that binary search
             has an upper bound on the number of steps, so it does not yield a log factor.
            
             \note Consider recycling the list after usage to reduce allocations.
             \see Pathfinding.Util.ListPool
        </member>
        <member name="M:Pathfinding.PathUtilities.InvoluteOfCircle(System.Single,System.Single)">
            Returns the XZ coordinate of the involute of circle.
            \see http://en.wikipedia.org/wiki/Involute
        </member>
        <member name="M:Pathfinding.PathUtilities.GetPointsAroundPointWorld(UnityEngine.Vector3,Pathfinding.IRaycastableGraph,System.Collections.Generic.List{UnityEngine.Vector3},System.Single,System.Single)">
            Will calculate a number of points around \a p which are on the graph and are separated by \a clearance from each other.
            This is like GetPointsAroundPoint except that \a previousPoints are treated as being in world space.
            The average of the points will be found and then that will be treated as the group center.
        </member>
        <member name="M:Pathfinding.PathUtilities.GetPointsAroundPoint(UnityEngine.Vector3,Pathfinding.IRaycastableGraph,System.Collections.Generic.List{UnityEngine.Vector3},System.Single,System.Single)">
            Will calculate a number of points around \a p which are on the graph and are separated by \a clearance from each other.
             The maximum distance from \a p to any point will be \a radius.
             Points will first be tried to be laid out as \a previousPoints and if that fails, random points will be selected.
             This is great if you want to pick a number of target points for group movement. If you pass all current agent points from e.g the group's average position
             this method will return target points so that the units move very little within the group, this is often aesthetically pleasing and reduces jitter if using
             some kind of local avoidance.
            
             \param p The point to generate points around
             \param g The graph to use for linecasting. If you are only using one graph, you can get this by AstarPath.active.graphs[0] as IRaycastableGraph.
             Note that not all graphs are raycastable, recast, navmesh and grid graphs are raycastable. On recast and navmesh it works the best.
             \param previousPoints The points to use for reference. Note that these should not be in world space. They are treated as relative to \a p.
             \param radius The final points will be at most this distance from \a p.
             \param clearanceRadius The points will if possible be at least this distance from each other.
        </member>
        <member name="M:Pathfinding.PathUtilities.GetPointsOnNodes(System.Collections.Generic.List{Pathfinding.GraphNode},System.Int32,System.Single)">
            Returns randomly selected points on the specified nodes with each point being separated by \a clearanceRadius from each other.
             Selecting points ON the nodes only works for TriangleMeshNode (used by Recast Graph and Navmesh Graph) and GridNode (used by GridGraph).
             For other node types, only the positions of the nodes will be used.
            
             clearanceRadius will be reduced if no valid points can be found.
        </member>
        <member name="P:AstarPath.Version">
            The version number for the A* %Pathfinding Project
        </member>
        <member name="T:AstarPath.AstarDistribution">
            Information about where the package was downloaded 
        </member>
        <member name="F:AstarPath.Distribution">
            Used by the editor to guide the user to the correct place to download updates 
        </member>
        <member name="F:AstarPath.Branch">
            Which branch of the A* %Pathfinding Project is this release.
            Used when checking for updates so that
            users of the development versions can get notifications of development
            updates.
        </member>
        <member name="F:AstarPath.HasPro">
            Used by the editor to show some Pro specific stuff.
            Note that setting this to true will not grant you any additional features 
        </member>
        <member name="P:AstarPath.graphTypes">
            See Pathfinding.AstarData
            \deprecated
        </member>
        <member name="F:AstarPath.astarData">
            Holds all graph data 
        </member>
        <member name="F:AstarPath.active">
            Returns the active AstarPath object in the scene.
            \note This is only set if the AstarPath object has been initialized (which happens in Awake).
        </member>
        <member name="P:AstarPath.graphs">
            Shortcut to Pathfinding.AstarData.graphs 
        </member>
        <member name="F:AstarPath.showNavGraphs">
            @name Inspector - Debug
            @{ 
            Toggle for showing the gizmo debugging for the graphs in the scene view (editor only). 
        </member>
        <member name="F:AstarPath.showUnwalkableNodes">
            Toggle to show unwalkable nodes.
            
             \note Only relevant in the editor
            
             \see unwalkableNodeDebugSize
        </member>
        <member name="F:AstarPath.debugMode">
            The mode to use for drawing nodes in the sceneview.
            
             \note Only relevant in the editor
            
             \see Pathfinding.GraphDebugMode
        </member>
        <member name="F:AstarPath.debugFloor">
            Low value to use for certain #debugMode modes.
             For example if #debugMode is set to G, this value will determine when the node will be totally red.
            
             \note Only relevant in the editor
             \see #debugRoof
        </member>
        <member name="F:AstarPath.debugRoof">
            High value to use for certain #debugMode modes.
             For example if #debugMode is set to G, this value will determine when the node will be totally green.
            
             For the penalty debug mode, the nodes will be colored green when they have a penalty of zero and red
             when their penalty is greater or equal to this value and something between red and green for values in between.
            
             \note Only relevant in the editor
            
             \see #debugFloor
            
        </member>
        <member name="F:AstarPath.manualDebugFloorRoof">
            If set, the #debugFloor and #debugRoof values will not be automatically recalculated.
            
             \note Only relevant in the editor
        </member>
        <member name="F:AstarPath.showSearchTree">
            If enabled, nodes will draw a line to their 'parent'.
             This will show the search tree for the latest path.
            
             \note Only relevant in the editor
            
             \todo Add a showOnlyLastPath flag to indicate whether to draw every node or only the ones visited by the latest path.
        </member>
        <member name="F:AstarPath.unwalkableNodeDebugSize">
            Size of the red cubes shown in place of unwalkable nodes.
            
             \note Only relevant in the editor
             \see showUnwalkableNodes 
        </member>
        <member name="F:AstarPath.logPathResults">
            The amount of debugging messages.
            Use less debugging to improve performance (a bit) or just to get rid of the Console spamming.\n
            Use more debugging (heavy) if you want more information about what the pathfinding is doing.\n
            InGame will display the latest path log using in game GUI.
        </member>
        <member name="F:AstarPath.maxNearestNodeDistance">
            @name Inspector - Settings
            @{ 
            Max Nearest Node Distance.
            When searching for a nearest node, this is the limit (world units) for how far away it is allowed to be.
            \see Pathfinding.NNConstraint.constrainDistance
        </member>
        <member name="P:AstarPath.maxNearestNodeDistanceSqr">
            Max Nearest Node Distance Squared.
            \see #maxNearestNodeDistance 
        </member>
        <member name="F:AstarPath.scanOnStartup">
            If true, all graphs will be scanned in Awake.
            This does not include loading from the cache.
            If you disable this, you will have to call \link Scan AstarPath.active.Scan () \endlink yourself to enable pathfinding.
            Alternatively you could load a saved graph from a file.
        </member>
        <member name="F:AstarPath.fullGetNearestSearch">
            Do a full GetNearest search for all graphs.
            Additional searches will normally only be done on the graph which in the first fast search seemed to have the closest node.
            With this setting on, additional searches will be done on all graphs since the first check is not always completely accurate.\n
            More technically: GetNearestForce on all graphs will be called if true, otherwise only on the one graph which's GetNearest search returned the best node.\n
            Usually faster when disabled, but higher quality searches when enabled.
            When using a a navmesh or recast graph, for best quality, this setting should be combined with the Pathfinding.NavMeshGraph.accurateNearestNode setting set to true.
            \note For the PointGraph this setting doesn't matter much as it has only one search mode.
        </member>
        <member name="F:AstarPath.prioritizeGraphs">
            Prioritize graphs.
            Graphs will be prioritized based on their order in the inspector.
            The first graph which has a node closer than #prioritizeGraphsLimit will be chosen instead of searching all graphs.
        </member>
        <member name="F:AstarPath.prioritizeGraphsLimit">
            Distance limit for #prioritizeGraphs.
            \see #prioritizeGraphs
        </member>
        <member name="F:AstarPath.colorSettings">
            Reference to the color settings for this AstarPath object.
            Color settings include for example which color the nodes should be in, in the sceneview. 
        </member>
        <member name="F:AstarPath.tagNames">
            Stored tag names.
            \see AstarPath.FindTagNames
            \see AstarPath.GetTagNames
        </member>
        <member name="F:AstarPath.heuristic">
            The heuristic to use.
            The heuristic, often referred to as 'H' is the estimated cost from a node to the target.
            Different heuristics affect how the path picks which one to follow from multiple possible with the same length
            \see Pathfinding.Heuristic
        </member>
        <member name="F:AstarPath.heuristicScale">
            The scale of the heuristic. If a smaller value than 1 is used, the pathfinder will search more nodes (slower).
            If 0 is used, the pathfinding will be equal to dijkstra's algorithm.
            If a value larger than 1 is used the pathfinding will (usually) be faster because it expands fewer nodes, but the paths might not longer be optimal
        </member>
        <member name="F:AstarPath.threadCount">
            Number of pathfinding threads to use.
             Multithreading puts pathfinding in another thread, this is great for performance on 2+ core computers since the framerate will barely be affected by the pathfinding at all.
             - None indicates that the pathfinding is run in the Unity thread as a coroutine
             - Automatic will try to adjust the number of threads to the number of cores and memory on the computer.
              Less than 512mb of memory or a single core computer will make it revert to using no multithreading.
            
             It is recommended that you use one of the "Auto" settings that are available.
             The reason is that even if your computer might be beefy and have 8 cores.
             Other computers might only be quad core or dual core in which case they will not benefit from more than
             1 or 3 threads respectively (you usually want to leave one core for the unity thread).
             If you use more threads than the number of cores on the computer it is mostly just wasting memory, it will not run any faster.
             The extra memory usage is not trivially small. Each thread needs to keep a small amount of data for each node in all the graphs.
             It is not the full graph data but it is proportional to the number of nodes.
             The automatic settings will inspect the machine it is running on and use that to determine the number of threads so that no memory is wasted.
            
             The exception is if you only have one (or maybe two characters) active at time. Then you should probably just go with one thread always since it is very unlikely
             that you will need the extra throughput given by more threads. Keep in mind that more threads primarily increases throughput by calculating different paths on different
             threads, it will not calculate individual paths any faster.
            
             Note that if you are modifying the pathfinding core scripts or if you are directly modifying graph data without using any of the
             safe wrappers (like RegisterSafeUpdate) multithreading can cause strange errors and pathfinding stopping to work if you are not careful.
             For basic usage (not modding the pathfinding core) it should be safe.\n
            
             \note WebGL does not support threads at all (since javascript is single-threaded)
            
             \see CalculateThreadCount
            
             \astarpro
        </member>
        <member name="F:AstarPath.maxFrameTime">
            Max number of milliseconds to spend each frame for pathfinding.
            At least 500 nodes will be searched each frame (if there are that many to search).
            When using multithreading this value is quite irrelevant,
            but do not set it too low since that could add upp to some overhead, 10ms will work good for multithreading 
        </member>
        <member name="F:AstarPath.minAreaSize">
            Defines the minimum amount of nodes in an area.
             If an area has less than this amount of nodes, the area will be flood filled again with the area ID GraphNode.MaxAreaIndex-1,
             it shouldn't affect pathfinding in any significant way.\n
             If you want to be able to separate areas from one another for some reason (for example to do a fast check to see if a path is at all possible)
             you should set this variable to 0.\n
             Can be found in A* Inspector-->Settings-->Min Area Size
            
             \version Since version 3.6, this variable should in most cases be set to 0 since the max number of area indices available has been greatly increased.
        </member>
        <member name="F:AstarPath.batchGraphUpdates">
            Throttle graph updates and batch them to improve performance.
             If toggled, graph updates will batched and executed less often (specified by #graphUpdateBatchingInterval).
            
             This can have a positive impact on pathfinding throughput since the pathfinding threads do not need
             to be stopped as often, and it reduces the overhead per graph update.
             All graph updates are still applied however, they are just batched together so that more of them are
             applied at the same time.
            
             However do not use this if you want minimal latency between a graph update being requested
             and it being applied.
             This only applies to graph updates requested using the UpdateGraphs method. Not those requested
             using RegisterSafeUpdate or AddWorkItem.
            
        </member>
        <member name="F:AstarPath.graphUpdateBatchingInterval">
            How often should graphs be updated.
             If #batchGraphUpdates is true, this defines the minimum number of seconds between each graph update.
            
             This can have a positive impact on pathfinding throughput since the pathfinding threads do not need
             to be stopped as often, and it reduces the overhead per graph update.
             All graph updates are still applied however, they are just batched together so that more of them are
             applied at the same time.
            
             However do not use this if you want minimal latency between a graph update being requested
             and it being applied.
             This only applies to graph updates requested using the UpdateGraphs method. Not those requested
             using RegisterSafeUpdate or AddWorkItem.
            
        </member>
        <member name="P:AstarPath.limitGraphUpdates">
            Batch graph updates.
            \deprecated This field has been renamed to 'batchGraphUpdates'.
        </member>
        <member name="P:AstarPath.maxGraphUpdateFreq">
            Limit for how often should graphs be updated.
            \deprecated This field has been renamed to 'graphUpdateBatchingInterval'.
        </member>
        <member name="F:AstarPath.lastScanTime">
            @name Debug Members
            @{ 
            The time it took for the last call to Scan() to complete.
            Used to prevent automatically rescanning the graphs too often (editor only)
        </member>
        <member name="F:AstarPath.debugPath">
            The path to debug using gizmos.
            This is equal to the last path which was calculated.
            It is used in the editor to draw debug information using gizmos.
        </member>
        <member name="P:AstarPath.debugPathData">
            NodeRunData from #debugPath.
            Returns null if #debugPath is null
        </member>
        <member name="F:AstarPath.inGameDebugPath">
            Debug string from the last completed path.
            Will be updated if #logPathResults == PathLog.InGame
        </member>
        <member name="P:AstarPath.isScanning">
            Set when scanning is being done. It will be true up until the FloodFill is done.
            Used to better support Graph Update Objects called for example in OnPostScan 
        </member>
        <member name="P:AstarPath.NumParallelThreads">
            Number of parallel pathfinders.
            Returns the number of concurrent processes which can calculate paths at once.
            When using multithreading, this will be the number of threads, if not using multithreading it is always 1 (since only 1 coroutine is used).
            \see threadInfos
            \see IsUsingMultithreading
        </member>
        <member name="P:AstarPath.IsUsingMultithreading">
            Returns whether or not multithreading is used.
            \exception System.Exception Is thrown when it could not be decided if multithreading was used or not.
            This should not happen if pathfinding is set up correctly.
            \note This uses info about if threads are running right now, it does not use info from the settings on the A* object.
        </member>
        <member name="P:AstarPath.IsAnyGraphUpdatesQueued">
            Returns if any graph updates are waiting to be applied 
        </member>
        <member name="F:AstarPath.isRegisteredForUpdate">
            Makes sure QueueGraphUpdates will not queue multiple graph update orders 
        </member>
        <member name="F:AstarPath.workItemsQueued">
            True if any work items are currently queued 
        </member>
        <member name="F:AstarPath.queuedWorkItemFloodFill">
            True if any work items have queued a flood fill.
            \see QueueWorkItemFloodFill
        </member>
        <!-- Badly formed XML comment ignored for member "F:AstarPath.OnAwakeSettings" -->
        <member name="F:AstarPath.OnGraphPreScan">
            Called for each graph before they are scanned 
        </member>
        <member name="F:AstarPath.OnGraphPostScan">
            Called for each graph after they have been scanned. All other graphs might not have been scanned yet. 
        </member>
        <member name="F:AstarPath.OnPathPreSearch">
            Called for each path before searching. Be careful when using multithreading since this will be called from a different thread. 
        </member>
        <member name="F:AstarPath.OnPathPostSearch">
            Called for each path after searching. Be careful when using multithreading since this will be called from a different thread. 
        </member>
        <member name="F:AstarPath.OnPreScan">
            Called before starting the scanning 
        </member>
        <member name="F:AstarPath.OnPostScan">
            Called after scanning. This is called before applying links, flood-filling the graphs and other post processing. 
        </member>
        <member name="F:AstarPath.OnLatePostScan">
            Called after scanning has completed fully. This is called as the last thing in the Scan function. 
        </member>
        <member name="F:AstarPath.OnGraphsUpdated">
            Called when any graphs are updated. Register to for example recalculate the path whenever a graph changes. 
        </member>
        <member name="F:AstarPath.On65KOverflow">
            Called when \a pathID overflows 65536 and resets back to zero.
            \note This callback will be cleared every time it is called, so if you want to register to it repeatedly, register to it directly on receiving the callback as well.
        </member>
        <member name="F:AstarPath.OnThreadSafeCallback">
            Will send a callback when it is safe to update the nodes. Register to this with RegisterThreadSafeNodeUpdate
            When it is safe is defined as between the path searches.
            This callback will only be sent once and is nulled directly after the callback is sent.
        </member>
        <member name="F:AstarPath.OnDrawGizmosCallback">
            Used internally to enable gizmos in editor scripts.
            \warning Used internally by the editor, do not use this in your code
        </member>
        <member name="F:AstarPath.OnUnloadGizmoMeshes">
            Used internally to unload temporary meshes in the editor.
            \warning Used internally by the editor, do not use this in your code
        </member>
        <member name="F:AstarPath.OnGraphsWillBeUpdated">
            \deprecated 
        </member>
        <member name="F:AstarPath.OnGraphsWillBeUpdated2">
            \deprecated 
        </member>
        <member name="F:AstarPath.graphUpdateQueue">
            Stack containing all waiting graph update queries. Add to this stack by using \link UpdateGraphs \endlink
            \see UpdateGraphs
        </member>
        <member name="F:AstarPath.floodStack">
            Stack used for flood-filling the graph. It is saved to minimize memory allocations. 
        </member>
        <member name="F:AstarPath.pathQueue">
            Holds all paths waiting to be calculated 
        </member>
        <member name="F:AstarPath.threads">
            References to each of the pathfinding threads 
        </member>
        <member name="F:AstarPath.graphUpdateThread">
            Reference to the thread which handles async graph updates.
            \see ProcessGraphUpdatesAsync
        </member>
        <member name="F:AstarPath.threadInfos">
            Holds info about each thread.
            The first item will hold information about the pathfinding coroutine when not using multithreading.
        </member>
        <member name="F:AstarPath.threadEnumerator">
            When no multithreading is used, the IEnumerator is stored here.
            When no multithreading is used, a coroutine is used instead. It is not directly called with StartCoroutine
            but a separate function has just a while loop which increments the main IEnumerator.
            This is done so other functions can step the thread forward at any time, without having to wait for Unity to update it.
            \see CalculatePaths
            \see CalculatePathsHandler
        </member>
        <member name="F:AstarPath.pathReturnStack">
            Holds all paths which are waiting to be flagged as completed.
            \see ReturnPaths
        </member>
        <member name="F:AstarPath.euclideanEmbedding">
            Holds settings for heuristic optimization.
             \see heuristic-opt
            
             \astarpro
        </member>
        <member name="F:AstarPath.nextNodeIndex">
            Holds the next node index which has not been used by any previous node.
            \see nodeIndexPool
        </member>
        <member name="F:AstarPath.nodeIndexPool">
            Holds indices for nodes that have been destroyed.
            To avoid trashing a lot of memory structures when nodes are
            frequently deleted and created, node indices are reused.
        </member>
        <member name="F:AstarPath.pathReturnPop">
            A temporary queue for paths which weren't returned due to large processing time.
             When some time limit is exceeded in ReturnPaths, paths are put in this queue until the next frame.
            
             Paths contain a member called 'next', so this actually forms a linked list.
            
             \see ReturnPaths
        </member>
        <member name="F:AstarPath.graphUpdateQueueAsync">
            Queue of all async graph updates waiting to be executed 
        </member>
        <member name="F:AstarPath.graphUpdateQueueRegular">
            Queue of all non-async graph updates waiting to be executed 
        </member>
        <member name="T:AstarPath.GraphUpdateOrder">
            Order type for updating graphs 
        </member>
        <member name="T:AstarPath.GUOSingle">
            Holds a single update that needs to be performed on a graph 
        </member>
        <member name="F:AstarPath.showGraphs">
            Shows or hides graph inspectors.
            Used internally by the editor 
        </member>
        <member name="F:AstarPath.lastUniqueAreaIndex">
            The last area index which was used.
            Used for the \link FloodFill(GraphNode node) FloodFill \endlink function to start flood filling with an unused area.
            \see FloodFill(Node node)
        </member>
        <member name="F:AstarPath.graphUpdateAsyncEvent">
            \todo Should be signaled in OnDestroy 
        </member>
        <member name="F:AstarPath.lastGraphUpdate">
            Time the last graph update was done.
            Used to group together frequent graph updates to batches 
        </member>
        <member name="F:AstarPath.nextFreePathID">
            The next unused Path ID.
            Incremented for every call to GetFromPathPool 
        </member>
        <member name="M:AstarPath.GetTagNames">
            Returns tag names.
            Makes sure that the tag names array is not null and of length 32.
            If it is null or not of length 32, it creates a new array and fills it with 0,1,2,3,4 etc...
            \see AstarPath.FindTagNames
        </member>
        <member name="M:AstarPath.FindTagNames">
            Tries to find an AstarPath object and return tag names.
            If an AstarPath object cannot be found, it returns an array of length 1 with an error message.
            \see AstarPath.GetTagNames
        </member>
        <member name="M:AstarPath.GetNextPathID">
            Returns the next free path ID 
        </member>
        <member name="M:AstarPath.OnDrawGizmos">
            Calls OnDrawGizmos on graph generators and also #OnDrawGizmosCallback 
        </member>
        <member name="M:AstarPath.DrawUnwalkableNode(Pathfinding.GraphNode)">
            Draws a cube at the node's position if unwalkable.
            Used for gizmo drawing
        </member>
        <member name="M:AstarPath.OnGUI">
            Draws the InGame debugging (if enabled), also shows the fps if 'L' is pressed down.
            \see #logPathResults PathLog
        </member>
        <member name="M:AstarPath.AstarLog(System.String)">
            Logs a string while taking into account #logPathResults 
        </member>
        <member name="M:AstarPath.AstarLogError(System.String)">
            Logs an error string while taking into account #logPathResults 
        </member>
        <member name="M:AstarPath.LogPathResults(Pathfinding.Path)">
            Prints path results to the log. What it prints can be controled using #logPathResults.
            \see #logPathResults
            \see PathLog
            \see Pathfinding.Path.DebugString
        </member>
        <member name="F:AstarPath.AstarWorkItem.init">
            Init function.
            May be null if no initialization is needed.
            Will be called once, right before the first call to #update.
        </member>
        <member name="F:AstarPath.AstarWorkItem.update">
            Update function, called once per frame when the work item executes.
            Takes a param \a force. If that is true, the work item should try to complete the whole item in one go instead
            of spreading it out over multiple frames.
            \returns True when the work item is completed.
        </member>
        <member name="M:AstarPath.QueueWorkItemFloodFill">
            Call during work items to queue a flood fill.
             An instant flood fill can be done via FloodFill()
             but this method can be used to batch several updates into one
             to increase performance.
             WorkItems which require a valid Flood Fill in their execution can call EnsureValidFloodFill
             to ensure that a flood fill is done if any earlier work items queued one.
            
             Once a flood fill is queued it will be done after all WorkItems have been executed.
        </member>
        <member name="M:AstarPath.EnsureValidFloodFill">
            If a WorkItem needs to have a valid flood fill during execution, call this method to ensure there are no pending flood fills.
        </member>
        <member name="M:AstarPath.AddWorkItem(AstarPath.AstarWorkItem)">
            Add a work item to be processed when pathfinding is paused.
            
             \see ProcessWorkItems
        </member>
        <member name="M:AstarPath.ProcessWorkItems(System.Boolean)">
            Process graph updating work items.
             Process all queued work items, e.g graph updates and the likes.
            
             \returns
             - 0 if there were no work items to be processed or if nothing can be done
              because pathfinding is not paused.
             - 1 if there are still items to be processed.
             - 2 if the last work items was processed and pathfinding threads are ready to be resumed.
            
             \see AddWorkItem
             \see threadSafeUpdateState
             \see Update
        </member>
        <member name="M:AstarPath.QueueGraphUpdates">
            Will apply queued graph updates as soon as possible, regardless of #batchGraphUpdates.
            Calling this multiple times will not create multiple callbacks.
            Makes sure DoUpdateGraphs is called as soon as possible.\n
            This function is useful if you are limiting graph updates, but you want a specific graph update to be applied as soon as possible regardless of the time limit.
            \see FlushGraphUpdates
        </member>
        <member name="M:AstarPath.DelayedGraphUpdate">
            Waits a moment with updating graphs.
            If batchGraphUpdates is set, we want to keep some space between them to let pathfinding threads running and then calculate all queued calls at once
        </member>
        <member name="M:AstarPath.UpdateGraphs(UnityEngine.Bounds,System.Single)">
            Update all graphs within \a bounds after \a t seconds.
            This function will add a GraphUpdateObject to the #graphUpdateQueue.
            The graphs will be updated as soon as possible.
        </member>
        <member name="M:AstarPath.UpdateGraphs(Pathfinding.GraphUpdateObject,System.Single)">
            Update all graphs using the GraphUpdateObject after \a t seconds.
            This can be used to, e.g make all nodes in an area unwalkable, or set them to a higher penalty.
        </member>
        <member name="M:AstarPath.UpdateGraphsInteral(Pathfinding.GraphUpdateObject,System.Single)">
            Update all graphs using the GraphUpdateObject after \a t seconds 
        </member>
        <member name="M:AstarPath.UpdateGraphs(UnityEngine.Bounds)">
            Update all graphs within \a bounds.
             This function will add a GraphUpdateObject to the #graphUpdateQueue.
             The graphs will be updated as soon as possible.
            
             This is equivalent to\n
             UpdateGraphs (new GraphUpdateObject (bounds))
            
             \see FlushGraphUpdates
        </member>
        <member name="M:AstarPath.UpdateGraphs(Pathfinding.GraphUpdateObject)">
            Update all graphs using the GraphUpdateObject.
             This can be used to, e.g make all nodes in an area unwalkable, or set them to a higher penalty.
             The graphs will be updated as soon as possible (with respect to #batchGraphUpdates)
            
             \see FlushGraphUpdates
        </member>
        <member name="M:AstarPath.FlushGraphUpdates">
            Forces graph updates to run.
             This will force all graph updates to run immidiately. Or more correctly, it will block the Unity main thread until graph updates can be performed and then issue them.
             This will force the pathfinding threads to finish calculate the path they are currently calculating (if any) and then pause.
             When all threads have paused, graph updates will be performed.
             \warning Using this very often (many times per second) can reduce your fps due to a lot of threads waiting for one another.
             But you probably wont have to worry about that.
            
             \note This is almost identical to FlushThreadSafeCallbacks, but added for more descriptive name.
             This function will also override any time limit delays for graph updates.
             This is because graph updates are implemented using thread safe callbacks.
             So calling this function will also call other thread safe callbacks (if any are waiting).
            
             Will not do anything if there are no graph updates queued (not even call other callbacks).
        </member>
        <member name="M:AstarPath.FlushWorkItems(System.Boolean,System.Boolean)">
            Make sure work items are executed.
            
             \param unblockOnComplete If true, pathfinding will be allowed to start running immediately after completing all work items.
             \param block If true, work items that take more than one frame to complete will be force to complete during this call.
                          If false, then after this call there might still be work left to do.
            
             \see AddWorkItem
        </member>
        <member name="M:AstarPath.QueueGraphUpdatesInternal">
            Schedules graph updates internally 
        </member>
        <member name="M:AstarPath.ProcessGraphUpdates(System.Boolean)">
            Updates graphs.
             Will do some graph updates, possibly signal another thread to do them.
             Will only process graph updates added by QueueGraphUpdatesInternal
            
             \param force If true, all graph updates will be processed before this function returns. The return value
             will be True.
            
             \returns True if all graph updates have been done and pathfinding (or other tasks) may resume.
             False if there are still graph updates being done or waiting in the queue.
            
            
        </member>
        <member name="M:AstarPath.ProcessGraphUpdatesAsync(System.Object)">
            Graph update thread.
            Async graph updates will be executed by this method in another thread.
        </member>
        <member name="M:AstarPath.FlushThreadSafeCallbacks">
            Forces thread safe callbacks to run.
             This will force all thread safe callbacks to run immidiately. Or rather, it will block the Unity main thread until callbacks can be called and then issue them.
             This will force the pathfinding threads to finish calculate the path they are currently calculating (if any) and then pause.
             When all threads have paused, thread safe callbacks will be called (which can be e.g graph updates).
            
             \warning Using this very often (many times per second) can reduce your fps due to a lot of threads waiting for one another.
             But you probably wont have to worry about that
            
             \note This is almost (note almost) identical to FlushGraphUpdates, but added for more appropriate name.
        </member>
        <!-- Badly formed XML comment ignored for member "M:AstarPath.CalculateThreadCount(ThreadCount)" -->
        <member name="M:AstarPath.Awake">
            Sets up all needed variables and scans the graphs.
            Calls Initialize, starts the ReturnPaths coroutine and scans all graphs.
            Also starts threads if using multithreading
            \see #OnAwakeSettings
        </member>
        <member name="M:AstarPath.VerifyIntegrity">
            Does simple error checking.
        </member>
        <member name="M:AstarPath.SetUpReferences">
            Internal method to make sure #active is set to this object and that #astarData is not null.
             Also calls OnEnable for the #colorSettings and initializes astarData.userConnections if it wasn't initialized before
            
             \note This is mostly for use internally by the system.
        </member>
        <member name="M:AstarPath.Initialize">
            Initializes various variables.
             \link SetUpReferences Sets up references \endlink,
             Searches for graph types, calls Awake on #astarData and on all graphs
            
             \see AstarData.FindGraphTypes
             \see SetUpReferences
        </member>
        <member name="M:AstarPath.OnDisable">
            Cleans up meshes to avoid memory leaks 
        </member>
        <member name="M:AstarPath.OnDestroy">
            Clears up variables and other stuff, destroys graphs.
            Note that when destroying an AstarPath object, all static variables such as callbacks will be cleared.
        </member>
        <member name="M:AstarPath.FloodFill(Pathfinding.GraphNode)">
            Floodfills starting from the specified node 
        </member>
        <member name="M:AstarPath.FloodFill(Pathfinding.GraphNode,System.UInt32)">
            Floodfills starting from 'seed' using the specified area 
        </member>
        <member name="M:AstarPath.FloodFill">
            Floodfills all graphs and updates areas for every node.
            The different colored areas that you see in the scene view when looking at graphs
            are called just 'areas', this method calculates which nodes are in what areas.
            \see Pathfinding.Node.area
        </member>
        <member name="M:AstarPath.GetNewNodeIndex">
            Returns a new global node index.
            \warning This method should not be called directly. It is used by the GraphNode constructor.
        </member>
        <member name="M:AstarPath.InitializeNode(Pathfinding.GraphNode)">
            Initializes temporary path data for a node.
            \warning This method should not be called directly. It is used by the GraphNode constructor.
        </member>
        <member name="M:AstarPath.DestroyNode(Pathfinding.GraphNode)">
            Destroyes the given node.
             This is to be called after the node has been disconnected from the graph so that it cannot be reached from any other nodes.
             It should only be called during graph updates, that is when the pathfinding threads are either not running or paused.
            
             \warning This method should not be called by user code. It is used internally by the system.
        </member>
        <member name="M:AstarPath.BlockUntilPathQueueBlocked">
            Blocks until all pathfinding threads are paused and blocked.
             A call to pathQueue.Unblock is required to resume pathfinding calculations. However in
             most cases you should never unblock the path queue, instead let the pathfinding scripts do that in the next update.
             Unblocking the queue when other tasks (e.g graph updates) are running can interfere and cause invalid graphs.
            
             \note In most cases this should not be called from user code.
        </member>
        <member name="M:AstarPath.Scan">
            Scans all graphs.
            Calling this method will recalculate all graphs in the scene.
            This method is pretty slow (depending on graph type and graph complexity of course), so it is advisable to use
            smaller graph updates whenever possible.
            \see graph-updates
        </member>
        <member name="M:AstarPath.ScanLoop(OnScanStatus)">
            Scans all graphs. This is a IEnumerable, you can loop through it to get the progress
            \code foreach (Progress progress in AstarPath.active.ScanLoop ()) {
            Debug.Log ("Scanning... " + progress.description + " - " + (progress.progress*100).ToString ("0") + "%");
            } \endcode
            \see Scan
        </member>
        <member name="M:AstarPath.WaitForPath(Pathfinding.Path)">
            Wait for the specified path to be calculated.
             Normally it takes a few frames for a path to get calculated and returned.
             This function will ensure that the path will be calculated when this function returns
             and that the callback for that path has been called.
            
             \note Do not confuse this with Pathfinding.Path.WaitForPath. This one will halt all operations until the path has been calculated
             while Pathfinding.Path.WaitForPath will wait using yield until it has been calculated.
            
             If requesting a lot of paths in one go and waiting for the last one to complete,
             it will calculate most of the paths in the queue (only most if using multithreading, all if not using multithreading).
            
             Use this function only if you really need to.
             There is a point to spreading path calculations out over several frames.
             It smoothes out the framerate and makes sure requesting a large
             number of paths at the same time does not cause lag.
            
             \note Graph updates and other callbacks might get called during the execution of this function.
            
             When the pathfinder is shutting down. I.e in OnDestroy, this function will not do anything.
            
             \param p The path to wait for. The path must be started, otherwise an exception will be thrown.
            
             \throws Exception if pathfinding is not initialized properly for this scene (most likely no AstarPath object exists)
             or if the path has not been started yet.
             Also throws an exception if critical errors occur such as when the pathfinding threads have crashed (which should not happen in normal cases).
             This prevents an infinite loop while waiting for the path.
            
             \see Pathfinding.Path.WaitForPath
        </member>
        <member name="M:AstarPath.RegisterSafeUpdate(System.Action,System.Boolean)">
            Will send a callback when it is safe to update nodes. This is defined as between the path searches.
             This callback will only be sent once and is nulled directly after the callback has been sent.
             When using more threads than one, calling this often might decrease pathfinding performance due to a lot of idling in the threads.
             Not performance as in it will use much CPU power,
             but performance as in the number of paths per second will probably go down (though your framerate might actually increase a tiny bit)
            
             You should only call this function from the main unity thread (i.e normal game code).
            
             \note The threadSafe parameter has been deprecated
             \deprecated
        </member>
        <member name="M:AstarPath.RegisterSafeUpdate(System.Action)">
            Will send a callback when it is safe to update nodes. This is defined as between the path searches.
             This callback will only be sent once and is nulled directly after the callback has been sent.
             When using more threads than one, calling this often might decrease pathfinding performance due to a lot of idling in the threads.
             Not performance as in it will use much CPU power,
             but performance as in the number of paths per second will probably go down (though your framerate might actually increase a tiny bit)
            
             You should only call this function from the main unity thread (i.e normal game code).
            
             \code
             var node = AstarPath.active.GetNearest (transform.position).node;
             AstarPath.RegisterSafeUpdate (delegate () {
                 node.walkable = false;
             });
             \endcode
            
             \code
             var node = AstarPath.active.GetNearest (transform.position).node;
             AstarPath.RegisterSafeUpdate (delegate () {
                 node.position = (Int3)transform.position;
             });
             \endcode
            
        </member>
        <member name="M:AstarPath.InterruptPathfinding">
            Blocks the path queue so that e.g work items can be performed 
        </member>
        <member name="M:AstarPath.StartPath(Pathfinding.Path,System.Boolean)">
            Puts the Path in queue for calculation.
             The callback specified when constructing the path will be called when the path has been calculated.
             Usually you should use the Seeker component instead of calling this function directly.
            
             \param p The path that should be put in queue for calculation
             \param pushToFront If true, the path will be pushed to the front of the queue, bypassing all waiting paths and making it the next path to be calculated.
             This can be useful if you have a path which you want to prioritize over all others. Be careful to not overuse it though.
             If too many paths are put in the front of the queue often, this can lead to normal paths having to wait a very long time before being calculated.
        </member>
        <member name="M:AstarPath.OnApplicationQuit">
            Terminates pathfinding threads when the application quits.
        </member>
        <member name="M:AstarPath.ReturnPaths(System.Boolean)">
            Returns all paths in the return stack.
             Paths which have been processed are put in the return stack.
             This function will pop all items from the stack and return them to e.g the Seeker requesting them.
            
             \param timeSlice Do not return all paths at once if it takes a long time, instead return some and wait until the next call.
        </member>
        <member name="M:AstarPath.CalculatePathsThreaded(System.Object)">
            Main pathfinding method (multithreaded).
             This method will calculate the paths in the pathfinding queue when multithreading is enabled.
            
             \see CalculatePaths
             \see StartPath
            
             \astarpro
        </member>
        <member name="M:AstarPath.CalculatePaths(System.Object)">
            Main pathfinding method.
             This method will calculate the paths in the pathfinding queue.
            
             \see CalculatePathsThreaded
             \see StartPath
        </member>
        <member name="M:AstarPath.GetNearest(UnityEngine.Vector3)">
            Returns the nearest node to a position using the specified NNConstraint.
            Searches through all graphs for their nearest nodes to the specified position and picks the closest one.\n
            Using the NNConstraint.None constraint.
            \see Pathfinding.NNConstraint
        </member>
        <member name="M:AstarPath.GetNearest(UnityEngine.Vector3,Pathfinding.NNConstraint)">
            Returns the nearest node to a position using the specified NNConstraint.
            Searches through all graphs for their nearest nodes to the specified position and picks the closest one.
            The NNConstraint can be used to specify constraints on which nodes can be chosen such as only picking walkable nodes.
            \see Pathfinding.NNConstraint
        </member>
        <member name="M:AstarPath.GetNearest(UnityEngine.Vector3,Pathfinding.NNConstraint,Pathfinding.GraphNode)">
            Returns the nearest node to a position using the specified NNConstraint.
            Searches through all graphs for their nearest nodes to the specified position and picks the closest one.
            The NNConstraint can be used to specify constraints on which nodes can be chosen such as only picking walkable nodes.
            \see Pathfinding.NNConstraint
        </member>
        <member name="M:AstarPath.GetNearest(UnityEngine.Ray)">
            Returns the node closest to the ray (slow).
            \warning This function is brute-force and very slow, use with caution
        </member>
        <member name="F:AstarDebugger.font">
            Font to use.
            A monospaced font is the best
        </member>
        <member name="T:PathLog">
            How path results are logged by the system 
        </member>
        <!-- Badly formed XML comment ignored for member "F:PathLog.Normal" -->
        <!-- Badly formed XML comment ignored for member "F:PathLog.Heavy" -->
        <!-- Badly formed XML comment ignored for member "F:PathLog.InGame" -->
        <!-- Badly formed XML comment ignored for member "F:PathLog.OnlyErrors" -->
        <member name="T:Heuristic">
            Heuristic to use. Heuristic is the estimated cost from the current node to the target 
        </member>
        <member name="T:GraphDebugMode">
            What data to draw the graph debugging with 
        </member>
        <member name="T:ConnectionType">
            Type of connection for a user placed link 
        </member>
        <member name="T:ProceduralGridMover">
            Moves a grid graph to follow a target.
            
             Attach this to some object in the scene and assign the target to e.g the player.
             Then the graph will follow that object around as it moves.
            
             This is useful if pathfinding is only necessary in a small region around an object (for example the player).
             It makes it possible to have vast open worlds (maybe procedurally generated) and still be able to use pathfinding on them.
            
             When the graph is moved you may notice an fps drop.
             If this grows too large you can try a few things:
             - Reduce the #updateDistance. This will make the updates smaller but more frequent.
               This only works to some degree however since an update has an inherent overhead.
             - Turn off erosion on the grid graph. This will reduce the number of nodes that need updating.
             - Reduce the grid size.
             - Turn on multithreading (A* Inspector -> Settings)
             - Disable Height Testing or Collision Testing in the grid graph. This can give a minor performance boost.
            
             \see Take a look at the example scene called "Procedural" for an example of how to use this script
            
             \version Since 3.6.8 this class can handle graph rotation other options such as isometric angle and aspect ratio.
        </member>
        <member name="F:ProceduralGridMover.updateDistance">
            Graph will be updated if the target is more than this number of nodes from the graph center.
             Note that this is in nodes, not world units.
            
             \version The unit was changed to nodes instead of world units in 3.6.8.
        </member>
        <member name="F:ProceduralGridMover.target">
            Graph will be moved to follow this target 
        </member>
        <member name="F:ProceduralGridMover.floodFill">
            Flood fill the graph after updating.
             If this is set to false, areas of the graph will not be recalculated.
             Enable this only if the graph will only have a single area (i.e
             from all walkable nodes there is a valid path to every other walkable
             node). One case where this might be appropriate is a large
             outdoor area such as a forrest.
             If there are multiple areas in the graph and this
             is not enabled, pathfinding could fail later on.
            
             Enabling it will make the graph updates faster.
        </member>
        <member name="F:ProceduralGridMover.graph">
            Grid graph to update 
        </member>
        <member name="F:ProceduralGridMover.tmp">
            Temporary buffer 
        </member>
        <member name="P:ProceduralGridMover.updatingGraph">
            True while the graph is being updated by this script 
        </member>
        <member name="M:ProceduralGridMover.Update">
            Update is called once per frame 
        </member>
        <member name="M:ProceduralGridMover.PointToGraphSpace(UnityEngine.Vector3)">
            Transforms a point from world space to graph space.
            In graph space, (0,0,0) is bottom left corner of the graph
            and one unit along the X and Z axes equals distance between two nodes
            the Y axis still uses world units
        </member>
        <member name="M:ProceduralGridMover.UpdateGraph">
            Updates the graph asynchronously.
            This will move the graph so that the target's position is the center of the graph.
            If the graph is already being updated, the call will be ignored.
        </member>
        <member name="M:ProceduralGridMover.UpdateGraphCoroutine">
            Async method for moving the graph 
        </member>
        <member name="F:ProceduralWorld.range">
            How far away to generate tiles 
        </member>
        <member name="F:ProceduralWorld.tileSize">
            World size of tiles 
        </member>
        <member name="F:ProceduralWorld.staticBatching">
            Enable static batching on generated tiles.
            Will improve overall FPS, but might cause FPS on
            some frames when static batching is done
        </member>
        <member name="F:ProceduralWorld.ProceduralPrefab.prefab">
            Prefab to use 
        </member>
        <member name="F:ProceduralWorld.ProceduralPrefab.density">
            Number of objects per square world unit 
        </member>
        <member name="F:ProceduralWorld.ProceduralPrefab.perlin">
            Multiply by [perlin noise].
            Value from 0 to 1 indicating weight.
        </member>
        <member name="F:ProceduralWorld.ProceduralPrefab.perlinPower">
            Perlin will be raised to this power.
            A higher value gives more distinct edges
        </member>
        <member name="F:ProceduralWorld.ProceduralPrefab.perlinOffset">
            Some offset to avoid identical density maps 
        </member>
        <member name="F:ProceduralWorld.ProceduralPrefab.perlinScale">
            Perlin noise scale.
            A higher value spreads out the maximums and minimums of the density.
        </member>
        <member name="F:ProceduralWorld.ProceduralPrefab.random">
            Multiply by [random].
            Value from 0 to 1 indicating weight.
        </member>
        <member name="F:ProceduralWorld.ProceduralPrefab.singleFixed">
            If checked, a single object will be created in the center of each tile 
        </member>
        <member name="F:ProceduralWorld.tiles">
            All tiles 
        </member>
        <member name="T:AIFollow">
            Example AI.
            \deprecated This script has been deprecated, use AIPath, RichAI or MineBotAI instead 
        </member>
        <member name="F:AIFollow.target">
            Target to move to 
        </member>
        <member name="F:AIFollow.repathRate">
            How often to search for a new path 
        </member>
        <member name="F:AIFollow.pickNextWaypointDistance">
            The minimum distance to a waypoint to consider it as "reached" 
        </member>
        <member name="F:AIFollow.targetReached">
            The minimum distance to the end point of a path to consider it "reached" (multiplied with #pickNextWaypointDistance).
            This value is multiplied with #pickNextWaypointDistance before it is used. Recommended range [0...1] 
        </member>
        <member name="F:AIFollow.speed">
            Units per second 
        </member>
        <member name="F:AIFollow.rotationSpeed">
            How fast the AI can turn around 
        </member>
        <member name="F:AIFollow.canSearch">
            Should paths be searched for.
            Setting this to false will make the AI not search for paths anymore, can save some CPU cycles.
            It will check every #repathRate seconds if it should start to search for paths again.
            \note It will not cancel paths which are currently being calculated 
        </member>
        <member name="F:AIFollow.canMove">
            Can it move. Enables or disables movement and rotation 
        </member>
        <member name="F:AIFollow.seeker">
            Seeker component which handles pathfinding calls 
        </member>
        <member name="F:AIFollow.controller">
            CharacterController which handles movement 
        </member>
        <member name="F:AIFollow.tr">
            Transform, cached because of performance 
        </member>
        <member name="F:AIFollow.path">
            This is the path the AI is currently following 
        </member>
        <member name="M:AIFollow.Start">
            Use this for initialization 
        </member>
        <member name="M:AIFollow.Reset">
            Will make the AI give up it's current path and stop completely. 
        </member>
        <member name="M:AIFollow.OnPathComplete(Pathfinding.Path)">
            Called when a path has completed it's calculation 
        </member>
        <member name="M:AIFollow.WaitToRepath">
            Waits the remaining time until the AI should issue a new path request.
            The remaining time is defined by Time.time - lastPathSearch 
        </member>
        <member name="M:AIFollow.Stop">
            Stops the AI.
            Also stops new search queries from being made
            \since Before 3.0.8 This does not prevent new path calls from making the AI move again
            \see #Resume
            \see #canMove
            \see #canSearch 
        </member>
        <member name="M:AIFollow.Resume">
            Resumes walking and path searching the AI.
            \since Added in 3.0.8
            \see #Stop
            \see #canMove
            \see #canSearch 
        </member>
        <member name="M:AIFollow.Repath">
            Recalculates the path to #target.
            Queries a path request to the Seeker, the path will not be calculated instantly, but will be put on a queue and calculated as fast as possible.
            It will wait if the current path request by this seeker has not been completed yet.
            \see Seeker.IsDone 
        </member>
        <member name="M:AIFollow.PathToTarget(UnityEngine.Vector3)">
            Start a new path moving to \a targetPoint 
        </member>
        <member name="M:AIFollow.ReachedEndOfPath">
            Called when the AI reached the end of path.
            This will be called once for every path it completes, so if you have a really fast repath rate it will call this function often if when it stands on the end point.
        </member>
        <member name="M:AIFollow.Update">
            Update is called once per frame 
        </member>
        <member name="M:AIFollow.OnDrawGizmos">
            Draws helper gizmos.
            Currently draws a circle around the current target point with the size showing how close the AI need to get to it for it to count as "reached".
        </member>
        <member name="T:AstarSmoothFollow2">
            Smooth Camera Following.
            \author http://wiki.unity3d.com/index.php/SmoothFollow2
        </member>
        <member name="T:DynamicGridObstacle">
            Attach this script to any obstacle with a collider to enable dynamic updates of the graphs around it.
             When the object has moved a certain distance (or actually when it's bounding box has changed by a certain amount) defined by #updateError
             it will call AstarPath.UpdateGraphs and update the graph around it.
            
             Make sure that any children colliders do not extend beyond the bounds of the collider attached to the
             GameObject that the DynamicGridObstacle component is attached to since this script only updates the graph
             using the bounds of the collider on the same GameObject.
            
             \note This script only works with GridGraph, PointGraph and LayerGridGraph
            
             \see AstarPath.UpdateGraphs
             \see graph-updates
        </member>
        <member name="F:DynamicGridObstacle.col">
            Collider to get bounds information from 
        </member>
        <member name="F:DynamicGridObstacle.tr">
            Cached transform component 
        </member>
        <member name="F:DynamicGridObstacle.updateError">
            The minimum change in world units along one of the axis of the bounding box of the collider to trigger a graph update 
        </member>
        <member name="F:DynamicGridObstacle.checkTime">
            Time in seconds between bounding box checks.
            If AstarPath.batchGraphUpdates is enabled, it is not beneficial to have a checkTime much lower
            than AstarPath.graphUpdateBatchingInterval because that will just add unnecessary many graph updates.
        </member>
        <member name="F:DynamicGridObstacle.prevBounds">
            Bounds of the collider the last time the graphs were updated 
        </member>
        <member name="F:DynamicGridObstacle.prevRotation">
            Rotation of the collider the last time the graphs were updated 
        </member>
        <member name="F:DynamicGridObstacle.prevEnabled">
            True if the collider was enabled last time the graphs were updated 
        </member>
        <member name="M:DynamicGridObstacle.OnDestroy">
            Revert graphs when destroyed.
            When the DynamicObstacle is destroyed, a last graph update should be done to revert nodes to their original state 
        </member>
        <member name="M:DynamicGridObstacle.BoundsVolume(UnityEngine.Bounds)">
            Returns the volume of a Bounds object. X*Y*Z 
        </member>
        <member name="T:ObjectPlacer">
            Small sample script for placing obstacles 
        </member>
        <member name="F:ObjectPlacer.direct">
            GameObject to place. Make sure the layer it is in is included in the collision mask on the GridGraph settings (assuming a GridGraph) 
        </member>
        <member name="F:ObjectPlacer.issueGUOs">
            Flush Graph Updates directly after placing. Slower, but updates are applied immidiately 
        </member>
        <member name="M:ObjectPlacer.Start">
            Issue a graph update object after placement 
        </member>
        <member name="T:ArmaBasica">
            <summary>
            El arma basica del juego, todas las armas heredan de ella
            </summary>
        </member>
        <member name="M:ArmaBasica.getMousePosition">
            <summary>
            captura y devuelve la posicion del raton en el mundo
            </summary>
            <returns>la posicion del raton en el mundo</returns>
        </member>
        <member name="M:ArmaBasica.getDireccionDisparo">
            <summary>
            Calcula un vector entre el arma y la posicion del raton
            </summary>
            <returns>el vector entre el raton y el jugador</returns>
        </member>
        <member name="M:ArmaBasica.moverArma">
            <summary>
            mueve el arma segun la posicon del raton
            </summary>
        </member>
        <member name="M:ArmaBasica.rotarArma">
            <summary>
            rota el arma para que apunte donde esta el puntero
            </summary>
        </member>
        <member name="M:ArmaBasica.calcularRatio(System.Single)">
            <summary>
            permite disparar el arma segun cuando se ha disparado por ultima vez y su tasa de fuego
            </summary>
            <param name="delayTime">la tasa de fuego del arma, cada cuanto puede disparar</param>
            <returns></returns>
        </member>
        <member name="T:ArmaEscopeta">
            <summary>
            un intento de hacer una escopeta
            No pudo ser terminado por falta de conocimientos de vectores relativos
            muchas de las funciones estan deprecated y no deberian ser usadas
            </summary>
        </member>
        <member name="M:ArmaEscopeta.disparar(UnityEngine.Vector2)">
            <summary>
            dispara el proyectil de este arma cada vez que el calcularRatio, la tasa de fuego, le deja
            </summary>
        </member>
        <member name="T:ArmaLanzaExplosivo">
            <summary>
            un tipo de arma que dispara municion explosiva
            </summary>
        </member>
        <member name="M:ArmaLanzaExplosivo.disparar">
            <summary>
            dispara el proyectil de este arma cada vez que el calcularRatio, la tasa de fuego, le deja
            </summary>
        </member>
        <member name="T:ArmaLanzallamas">
            <summary>
            el arma lanzallamas
            </summary>
        </member>
        <member name="M:ArmaLanzallamas.controlarDisparo">
            <summary>
            Controla que se pueda disparar o no
            </summary>
            <returns>si se puede disparar o no</returns>
        </member>
        <member name="M:ArmaLanzallamas.disparar">
            <summary>
            dispara el proyectil de este arma cada vez que el calcularRatio, la tasa de fuego, le deja
            </summary>
        </member>
        <member name="T:ArmaMelee">
            <summary>
            un tipo de arma a melee que hace daño cada vez que colisiona
            </summary>
        </member>
        <member name="T:ArmaPistola">
            <summary>
            tipo de arma que dispara proyectiles
            </summary>
        </member>
        <member name="M:ArmaPistola.controlarDisparo">
            <summary>
            controla que el arma puede o no disparar
            </summary>
            <returns>si el arma o no puede disparar</returns>
        </member>
        <member name="M:ArmaPistola.disparar">
            <summary>
            dispara el proyectil de este arma cada vez que el calcularRatio, la tasa de fuego, le deja
            </summary>
        </member>
        <member name="T:Explosivo">
            <summary>
            Contiene funciones que convierten al gameObject al que tenga el explosivo como atributo a una bomba
            </summary>
        </member>
        <member name="M:Explosivo.detonarBomba(UnityEngine.GameObject,System.Single,System.Int32)">
            <summary>
            Hace daño a todos los objetos en el area pasada por parametro
            </summary>
            <param name="bomba">El GameObject bomba creado anteriormente</param>
            <param name="delayTime">El tiempo de delay entre la llamada de la funcion y la detonacion de la bomba</param>
            <returns></returns>
        </member>
        <member name="M:Explosivo.OnCollisionEnter2D(UnityEngine.Collision2D)">
            <summary>
            si la bomba se choca con algo despues de haber sido colocada, explota
            </summary>
            <param name="coll">la collision</param>
        </member>
        <member name="T:Llama">
            <summary>
            el pseudoproyectil que dispara el lanzallamas
            </summary>
        </member>
        <member name="T:Proyectil">
            <summary>
            el proyectil basico que disparan las armaPistola
            </summary>
        </member>
        <member name="M:Proyectil.OnCollisionEnter2D(UnityEngine.Collision2D)">
            <summary>
            controla que cuando se choque con un muro le baje la vida o si es con un enemigo le baje la vida
            </summary>
            <param name="coll">la collision que ha ocurrido</param>
        </member>
        <member name="M:Enemigo.OnPathComplete(Pathfinding.Path)">
            <summary>
            Función que se ejecuta al completar el path por A*
            </summary>
            <param name="p">Path que se ha completado</param>
        </member>
        <member name="M:Enemigo.perseguirJugador">
            <summary>
            Función que hace al enemigo persiguir al jugador
            </summary>
        </member>
        <member name="M:Enemigo.OnCollisionEnter2D(UnityEngine.Collision2D)">
            <summary>
            Función que determina las colisiones con otros objetos que cuenten con un rigidbody
            </summary>
            <param name="coll">Elemento con el que se colisiona</param>
        </member>
        <member name="M:Enemigo.OnCollisionStay2D(UnityEngine.Collision2D)">
            <summary>
            Función que determina si el enemigo está actualmente en contacto con un objeto.
            </summary>
            <param name="coll">Elemento con el que se colisiona</param>
        </member>
        <member name="M:Enemigo.dentroRadioJugador">
            <summary>
            Comprueba si el jugador está dentro de un radio determinado.
            </summary>
            <returns>Jugador dentro del radio o no</returns>
        </member>
        <member name="T:GestorHUD">
            <summary>
            el gestor del hud que se muestra
            </summary>
        </member>
        <member name="M:GestorHUD.refrescar">
            <summary>
            refresca los valores de los textos de salud y materiales
            </summary>
        </member>
        <member name="M:GestorHUD.controlarMuerte">
            <summary>
            controla que se muestren los objetos correctos cuando el jugador o la base mueren
            </summary>
        </member>
        <member name="M:GestorHUD.mostrarBotones">
            <summary>
            controla la pulsacion del boton de mostrar el menu de seleccion de arma
            </summary>
        </member>
        <member name="M:GestorHUD.controlarBotones">
            <summary>
            controla que el menu de seleccion de arma sea visible o no
            </summary>
        </member>
        <member name="M:GestorHUD.enableAlmacenBotones(System.Boolean)">
            <summary>
            cambia el estado de los botones del almacen de botones de eleccion de armas
            </summary>
            <param name="estado"> el estado que queremos darle a los botones</param>
        </member>
        <member name="M:GestorHUD.irMenu">
            <summary>
            boton de eleccion de volver al menu principal
            </summary>
        </member>
        <member name="M:GestorHUD.reiniciarMapa">
            <summary>
            boton de eleccion de reiniciar el juego
            </summary>
        </member>
        <member name="T:Jugador">
            <summary>
            el jugador que controlamos en el juego
            </summary>
        </member>
        <member name="M:Jugador.cambiarArma">
            <summary>
            Cambia de arma con la rueda del raton
            </summary>
        </member>
        <member name="M:Jugador.disparar">
            <summary>
            controla el disparar del jugador, si tiene suficientes materiales dispara y le quita los materiales necesarios
            </summary>
        </member>
        <member name="M:Jugador.elegirArma">
            <summary>
            elige un arma segun la tecla que pulses
            </summary>
        </member>
        <member name="M:Jugador.elegirArmaBoton(System.Int32)">
            <summary>
            Elige el armaseleccionada segun el boton pulsado en el HUD
            </summary>
            <param name="indexArma">el indice del arma que se quiere elegir</param>
        </member>
        <member name="M:Jugador.elegirArmaPorIndex(System.Int32)">
            <summary>
            selecciona un arma segun el index que le pases
            </summary>
            <param name="index">La posicion del almacenArmas del arma que se quiere equipar</param>
        </member>
        <member name="M:Jugador.aparecerArma">
            <summary>
            hace aparecer el arma seleccionada
            </summary>
        </member>
        <member name="M:Jugador.matarHijos(UnityEngine.GameObject)">
            <summary>
            mata a todos los hijos del objeto pasado por parametro
            </summary>
            <param name="padre">el objeto del que queremos matar todos los hijos</param>
        </member>
        <member name="M:Jugador.mover">
            <summary>
            mueve al jugador
            </summary>
            <param name="destino">La posicion a la que se quiere ir</param>
        </member>
        <member name="M:Jugador.mover2">
            <summary>
            modo secundario de movimiento, no implementado
            </summary>
        </member>
        <member name="M:Jugador.controlarMirada">
            <summary>
            Controla que el jugador siempre mire a la posicion del raton
            </summary>
        </member>
        <member name="M:Jugador.seleccionarGameObjectMouse">
            <summary>
            Devuelve el objeto debajo de la posicion del raton
            </summary>
            <returns>El objeto debajo de la posicion del raton</returns>
        </member>
        <member name="M:Jugador.getDistanciaMouseObject(UnityEngine.GameObject)">
            <summary>
            devuelve la distancia entre el personaje y el GameObject pasado como parametro
            </summary>
            <param name="jugador"></param>
            <returns>La distancia entre el personaje y el GameObject</returns>
        </member>
        <member name="M:Jugador.getMousePosition">
            <summary>
            Recoge la posicion del raton en el mundo y la devuelve
            </summary>
            <returns>la posicion del raton en el mundo</returns>
        </member>
        <member name="M:Jugador.resetImpulso">
            <summary>
            quita el impulso acumulado del objeto
            </summary>
        </member>
        <member name="M:Jugador.delayPicar(System.Single)">
            <summary>
            controla del delay de picar
            </summary>
            <param name="delayTime"></param>
            <returns></returns>
        </member>
        <member name="M:Jugador.picar">
            <summary>
            controla el picar del jugador
            </summary>
        </member>
        <member name="M:Jugador.construir">
            <summary>
            controla el construir del jugador
            </summary>
        </member>
        <member name="M:Jugador.controlarDestruccion">
            <summary>
            destruye el objeto seleccionado por seleccionarGameObjectMouse
            </summary>
        </member>
        <member name="M:Jugador.controlarConstruccion(UnityEngine.GameObject)">
            <summary>
            contruye un objeto en la posicion del raton, si no hay otro objeto en su posicion
            </summary>
            <param name="bloqueAConstruir">el gameobject que se va a colocar</param>
            <returns> el gameObject creado</returns>
        </member>
        <member name="M:Jugador.controlarBombas">
            <summary>
            controla el colocar bombas del jugador
            </summary>
        </member>
        <member name="M:Jugador.colocarBomba(System.Int32,System.Int32)">
            <summary>
            crea un objeto bomba y llama a detonarBomba()
            </summary>
        </member>
        <member name="M:MenuPrincipal.nuevaPartida">
            <summary>
            carga la nueva partida
            </summary>
        </member>
        <member name="M:MenuPrincipal.cerrarJuego">
            <summary>
            se cierra el juego, si esta en modo editor, se para la simulacion
            </summary>
        </member>
        <member name="M:MenuPrincipal.mostrarCanvas(UnityEngine.Canvas,System.Boolean,System.Single)">
            <summary>
            controla el delay del canvas a mostrar
            </summary>
            <param name="canvas">el canvas que queremos manipular</param>
            <param name="estado">el estado que le queremos dar</param>
            <param name="delayTime">el delay que queremos que tenga la orden</param>
            <returns></returns>
        </member>
        <member name="M:Muro.checkVida">
            <summary>
            Este método comprueba si el trozo de muro aun existe por la vida que tiene. En caso de ser mayor de 0 devuelve true.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Muro.bajarVida(System.Int32)">
            <summary>
            Este método baja la vida del muro dependiendo del parametro que le pasamos.
            </summary>
            <param name="danio"></param>
        </member>
        <member name="M:tempCamara.camara">
            <summary>
            Controla la camara y sigue al objetivo
            </summary>
        </member>
        <member name="M:tempCreadorMundo.crearMundo">
            <summary>
            Crea el mundo
            </summary>
        </member>
    </members>
</doc>
